{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Abstract","text":"<p>Thoughts are fleeting, and to keep them from slipping away, the author attempted to capture them in writing. Both silly and more serious thoughts were recorded. It became apparent that, while writing, the author gained a slightly better understanding of the topics at hand. Whether readers find it enjoyable remains to be seen.</p>"},{"location":"qip1/ch0.html","title":"Chapter 0: Introduction","text":"<p>My plan is to share my edited notes that I made whilst preparing for the teaching. I am doing it mainly in order to make sure I understand the topics, and motivate myself to be clear with explanations. I hope to give different intuition, which perhaps will be useful to some. </p> <p>In case of any queries and feedback, don't hesitate to contact me (wadamczyk@phys.ethz.ch)</p> <p>Resources: Which I used to write my notes - There is a lot of re-writing and paraphrasing, which I havent cited next to the sentence (the nature of notes)</p> <ul> <li>Principles of Quantum Mechanics (David Skinner) [1]</li> <li>Quantum Information Processing (J.P.Home) [2]</li> <li>Quantum Information and Computation (Richard Jozsa) [3]</li> <li>Foundations of Computer Science (Anil Madhavapeddy, Jonathan Ludlam) [4]</li> <li>Quantum Information (C.H.W. Barnes) [5]</li> </ul>"},{"location":"qip1/ch0.html#chapter-0-introduction","title":"Chapter 0: Introduction","text":"<p>Computation is about manipulation of information. Mathematically we can ponder on the different abstract schemes and systems to manipulate information, however, in practice we are very limited to what type of computation can we really do. \"Information is not a disembodied abstract entity; it is always tied to a physical representation\". [3] \"If information is represented in physical states or degrees of freedom of some physical system, then any possible act of computation, or information processing, must correspond to a physical evolution of that physical system.\" [3] This means that the rules of the computation must obey the laws of physics.</p> <p>Current paradigm of computing relies on classical physics, which in result constrains what operations can we perform on the computers. \"But that is not our World. To the best of our current experimental knowledge, our World is a quantum, not classical.\" [1] This gives us hope. If one carefully isolates and always consideres the whole system, we could enlarge the zoo of the operations we could perform. Extra tools could lead to different complexity classes of the algorithms that were previously not solvable by classical computers, and could aid in further understanding of the world. </p> <p>QIP-Implementation intends to show how can we build systems that can manipulate information using laws of quantum physics. QIP-Concepts intends to entertain the idea that we have the possibility of treating the information in a quantum way. We want to give you the grounding of exploring for yourself how does this change the paradigm of computation.</p> <p>In my notes I will largely \"ignore small formal subtleties, not because they're not interesting, but because they're a distraction from all the interesting physics we want to learn!\" [1]. I will actually skip some of the formalism introduced in the lecture if I feel like it hinders my own understanding of Quantum Mechanics. I am open to being criticised for it. </p>"},{"location":"qip1/ch0.html#chapter-01-why-do-we-care-about-quantum-computing","title":"Chapter 0.1: Why do we care about Quantum Computing","text":"<p>...</p>"},{"location":"qip1/ch1a.html","title":"Chapter 1a: Principles of Quantum Mechanics","text":""},{"location":"qip1/ch1a.html#11-hilbert-spaces","title":"1.1. Hilbert spaces:","text":"<p>Hilbert Space:</p> <ul> <li>Hilbert space is a vector space \\(\\mathcal{H}\\) over \\(\\mathbb{C}\\) that is equipped with a complete inner product. </li> <li>This definition has 3 keywords: <ul> <li>Vector space - is well known, </li> <li>Complete - is just a hedge against infinite Hilbert Spaces (unimportant)</li> <li>Inner Product is a map \\((\\quad,\\quad): \\mathcal{H} \\times \\mathcal{H} \\rightarrow \\mathbb{C}\\) that obeys</li> </ul> </li> </ul> \\[ \\begin{aligned} \\text { conjugate symmetry } &amp; (\\phi, \\psi)=\\overline{(\\psi, \\phi)} \\\\ \\text { linearity } &amp; (\\phi, a \\psi)=a(\\phi, \\psi) \\\\ \\text { additivity } &amp; (\\phi, \\psi+\\chi)=(\\phi, \\psi)+(\\phi, \\chi) \\\\ \\text { positive-definiteness } &amp; (\\psi, \\psi) \\geq 0 \\forall \\psi \\in \\mathcal{H} \\end{aligned} \\] <ul> <li>Metric of \\(\\mathcal{H}\\) is defined by the norm \\(\\|\\psi\\| \\equiv \\sqrt{(\\psi, \\psi)}\\)</li> <li>Quantum states can be represented as a vectors \\(\\psi \\in \\mathcal{H}\\)</li> </ul> <p>Dual Spaces:</p> <ul> <li>Dual space \\(\\mathcal{H^*}\\) of a \\(\\mathcal{H}\\) is the space of linear maps \\(\\mathcal{H} \\rightarrow \\mathbb{C}\\). That is, an element \\(\\phi \\in \\mathcal{H^*}\\) defines a map \\(\\varphi: \\psi \\mapsto \\varphi(\\psi) \\in \\mathbb{C}\\) for every \\(\\psi \\in \\mathcal{H}\\), such that </li> </ul> \\[ \\varphi: a \\psi_1+b \\psi_2 \\mapsto a \\varphi\\left(\\psi_1\\right)+b \\varphi\\left(\\psi_2\\right) \\] <ul> <li>One of the dual space \\(\\mathcal{H^*}\\) is for instance the inner product \\((\\phi, \\quad) \\in \\mathcal{H}^*\\) for \\(\\phi \\in \\mathcal{H}\\), where </li> </ul> \\[ (\\phi, \\quad): \\psi \\mapsto(\\phi, \\psi) \\]"},{"location":"qip1/ch1a.html#12-dirac-notation","title":"1.2. Dirac Notation:","text":"<p>In quantum mechanics quite often we often switch basis. This is because intrinsically any measurement causes a collapse onto the measurement basis. Because of this we want to have a notation that allows us to work with multiple basis at the same time, and not get confused. Dirac notation (empirically) provides this clarity. It is difficult to formally define the notation, and quite often when one does it, they get confused (unless they are deep down in theory). Therefore I would propose to learn it through learning the basic few properties and then trying things out. </p> <p>Dirac denotes element of \\(\\mathcal{H}\\) as \\(\\left|\\psi\\right&gt;\\) 'ket', and an element of the dual space is written as \\(\\mathcal{H^*}\\) as \\(\\left&lt;\\psi\\right|\\) 'bra'. The inner product between two states \\(\\left|\\psi\\right&gt;, \\left|\\phi\\right&gt; \\in \\mathcal{H}\\) is written as \\(\\left&lt;\\psi|\\phi\\right&gt;\\).</p> <p>In notes the bra-ket notation is introduced using homomorphisms (linear maps). I find it unecessary.</p> <ul> <li>The advantage of using bra-ket notation is:<ul> <li>We can talk about multiple things at the same time - Dirac notation is effectively just a label that points to an abstract object in the Hilbert space. We don't need to specify whether the variable is contineous, or if it is a vector or a function.</li> <li>Allows us to label states by their eigenvalues</li> <li>Somehow it is more natural and causes less confusion</li> </ul> </li> </ul>"},{"location":"qip1/ch1a.html#13-operators","title":"1.3. Operators:","text":"<ul> <li>A linear operator A is a map \\(A : \\mathcal{H} \\rightarrow \\mathcal{H}\\) that is compatible with the vector space structure \\(A(c_1\\left|\\phi_1\\right&gt; + c_2\\left|\\phi_2\\right&gt;) = c_1A\\left|\\phi_1\\right&gt; + c_2A\\left|\\phi_2\\right&gt;\\)</li> <li>All operators in Quantum Mechanics are linear, hence we will call them just 'operators'</li> <li>Operators form algebra<ul> <li>Sum: \\((\\alpha A+\\beta B):\\left|\\phi\\right&gt; \\mapsto \\alpha A\\left|\\phi\\right&gt;+\\beta B\\left|\\phi\\right&gt;\\)</li> <li>Product: \\(A B: \\phi \\mapsto A \\circ B\\left|\\phi\\right&gt;=A(B\\left|\\phi\\right&gt;)\\)</li> <li>Commutator: \\([A, B]=A B-B A\\)</li> </ul> </li> <li>A state \\(\\psi \\in \\mathcal{H}\\) is said to be an eigenstate of an operator A if \\(A\\left|\\psi\\right&gt; = a_\\psi\\left|\\psi\\right&gt;\\) with an associated eigenvalue '\\(a_\\psi\\)'.</li> <li>Adjoint \\(A^\\dagger\\) of an operator \\(A\\) is defined as \\(\\left&lt;\\phi\\right|A^{\\dagger}\\left| \\psi\\right&gt;=\\overline{\\left&lt;\\psi\\right|A\\left| \\phi\\right&gt;} \\quad\\)</li> <li>An operator \\(Q\\) is called Hermitian if \\(Q^\\dagger=Q\\)</li> <li>An operator \\(U\\) is called Unitary if \\(U^\\dagger U= U U^\\dagger = \\mathbb{I}\\)</li> <li>An operator \\(\\Pi\\) is called Projector if \\(\\Pi\\Pi= \\Pi\\)</li> </ul>"},{"location":"qip1/ch1a.html#14-composite-systems","title":"1.4. Composite systems:","text":"<p>Tensor Product</p> <ul> <li>Tensor product \\(\\mathcal{H}_1 \\otimes \\mathcal{H}_2\\) is a vector space over \\(\\mathbb{C}\\) spanned by all pairs of elements \\(\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\), where \\(\\left|e_a\\right&gt; \\in \\mathcal{H_1}\\), \\(\\left|f_\\alpha\\right&gt; \\in \\mathcal{H_2}\\)</li> <li>It is not true that a general element of \\(\\mathcal{H}_1 \\otimes \\mathcal{H}_2\\) necessarily takes the form \\(\\left|\\psi_1\\right&gt;\\otimes\\left|\\psi_2\\right&gt;\\)</li> <li>Rahter, a general element may be written as \\(\\left|\\Psi\\right&gt;=\\sum_{a, \\alpha} r_{a \\alpha}\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\)</li> <li>Elements of the form \\(\\left|\\psi_1\\right&gt;\\otimes\\left|\\psi_2\\right&gt;\\) are called simple, and the elements of the form \\(\\left|\\Psi\\right&gt;=\\sum_{a, \\alpha} r_{a \\alpha}\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\) are refered as entangled</li> <li>\\(\\left&lt;\\alpha\\otimes\\beta|\\alpha'\\otimes\\beta'\\right&gt; := \\left&lt;\\alpha|\\alpha'\\right&gt;\\left&lt;\\beta|\\beta'\\right&gt;\\)</li> <li>\\(\\left( S_\\alpha \\otimes T_\\beta \\right)\\left(\\alpha \\otimes \\beta\\right) = \\left(S_\\alpha\\alpha\\right)\\otimes\\left(T_\\beta\\beta\\right)\\) - apologies for being slightly sloppy - I think it is understandable what I mean though</li> </ul> <p>Tensor Product in action (states)</p> <ul> <li>Let's as an example consider that our states \\(\\left|\\alpha\\right&gt;_A \\text{ and } \\left|\\beta\\right&gt;_B\\) live both in \\(\\mathbb{C}^2_A\\) and \\(\\mathbb{C}^2_B\\) respectively. Then we can pick orthonormal basis of \\(\\mathbb{C}^2_A\\) to be \\(\\left\\{\\left|u_1\\right&gt;_A, \\left|u_2\\right&gt;_A \\right\\}\\), and of \\(\\mathbb{C}^2_B\\) to be \\(\\left\\{\\left|v_1\\right&gt;_B, \\left|v_2\\right&gt;_B \\right\\}\\)</li> <li>Then one can write \\(\\left|\\alpha\\right&gt;_A = a_1 \\left|u_1\\right&gt;_A + a_2 \\left|u_2\\right&gt;_A = a_1 \\begin{pmatrix} 1\\\\ 0 \\end{pmatrix}_A + a_2 \\begin{pmatrix} 0\\\\ 1 \\end{pmatrix}_A\\),</li> <li>and \\(\\left|\\beta\\right&gt;_B = b_1 \\left|v_1\\right&gt;_B + b_2 \\left|v_2\\right&gt;_B = b_1 \\begin{pmatrix} 1\\\\ 0 \\end{pmatrix}_B + b_2 \\begin{pmatrix} 0\\\\ 1 \\end{pmatrix}_B\\)</li> <li>This means that one can write </li> </ul> \\[ \\left|\\alpha\\right&gt;_A \\otimes \\left|\\beta\\right&gt;_B = \\begin{pmatrix} a_1\\\\ a_2 \\end{pmatrix}_A \\otimes \\begin{pmatrix} b_1\\\\ b_2 \\end{pmatrix}_B = \\begin{pmatrix} a_1b_1\\\\ a_1b_2\\\\ a_2b_1\\\\ a_2b_2 \\end{pmatrix} \\] <ul> <li>or sticking to the Dirac notation:</li> </ul> \\[ \\left|\\alpha\\right&gt;_A \\otimes \\left|\\beta\\right&gt;_B = \\sum_{i,j} a_i b_j \\left|u_i\\right&gt;_A \\otimes \\left|v_j\\right&gt;_B \\] <p>Tensor Product in action (operators)</p> <ul> <li>For operators \\(A\\) and \\(B\\) that live in \\(\\mathbb{C}^2_A\\) and \\(\\mathbb{C}^2_B\\) respectively, one can write \\(A = \\sum_{i,j} a_{ij} \\left|u_i\\right&gt;_A \\left&lt;u_j\\right|\\) and \\(B = \\sum_{i,j} b_{ij} \\left|v_i\\right&gt;_B \\left&lt;v_j\\right|\\)</li> <li>This means:</li> </ul> \\[ A \\otimes B = \\sum_{i,j,k,\\ell} a_{ij} b_{k\\ell} \\left|u_i\\right&gt;_A \\otimes \\left|v_k\\right&gt;_B \\left&lt;u_j\\right|\\otimes\\left&lt;v_\\ell\\right| \\] <ul> <li>or in vector form:</li> </ul> \\[ A \\otimes B = \\begin{pmatrix} a_{11}B &amp; a_{12}B\\\\ a_{21}B &amp; a_{22}B \\end{pmatrix} = \\begin{pmatrix} a_{11}b_{11} &amp; a_{11}b_{12} &amp; a_{12}b_{11} &amp; a_{12}b_{12}\\\\ a_{11}b_{21} &amp; a_{11}b_{22} &amp; a_{12}b_{21} &amp; a_{12}b_{22}\\\\ a_{21}b_{11} &amp; a_{21}b_{12} &amp; a_{22}b_{11} &amp; a_{22}b_{12}\\\\ a_{21}b_{21} &amp; a_{21}b_{22} &amp; a_{22}b_{21} &amp; a_{22}b_{22}\\\\ \\end{pmatrix} \\]"},{"location":"qip1/ch1a.html#15-postulates-of-quantum-mechanics","title":"1.5. Postulates of Quantum Mechanics:","text":"<ul> <li>(1) A quantum system A is associated with complex Hilber space \\(\\mathcal{H}\\). A physical state of an isolated system is represented by a normalised vector \\(\\left|\\psi\\right&gt; \\in \\mathcal{H}\\), which is unique up to a phase factor</li> <li>(2) The evolution of an isolated quantum system is reversible. In this formalism this corresponds to unitary evolution of the form \\(\\left|\\psi\\right&gt; \\mapsto U\\left|\\psi\\right&gt;\\) for \\(U \\in \\mathcal{U}(\\mathcal{H})\\), i.e. \\(U^{\\dagger} U=U U^{\\dagger}=\\mathbb{I}\\). The unitary is unique up to a phase factor</li> <li>(3) Composite system - For two quantum system A, and B with associated Hilber spaces \\(\\mathcal{H_A}\\) and \\(\\mathcal{H_B}\\) the Hilbert space \\(\\mathcal{H_{AB}}\\) associated with the composite system AB is isomorphic to the tensor product \\(\\mathcal{H_A}\\otimes\\mathcal{H_B}\\). For unitary operation on the subsystem we use: \\(U_A \\otimes \\mathbb{I}_B\\left|i j\\right&gt;_{A B} \\equiv U_A\\left|i j\\right&gt;_{A B}\\)</li> <li>(4) Measurement - A projective measurement on a quantum system with outcomes labelled \\({x}_x\\) is associated with a set of projectors \\({\\Pi_x}x\\) satisfying \\(\\sum_x \\Pi_x = \\mathbb{I}\\). <ul> <li>Probability of getting outcome x when measuring state $\\left|\\psi\\right&gt; is given by the Born rule: \\(Pr[x \\mid \\psi]=\\left\\langle\\psi\\left|\\Pi_x\\right| \\psi\\right\\rangle\\)</li> <li>Post-measurement state is given the outcome x is \\(\\left|\\psi_x^{\\prime}\\right&gt;=\\frac{1}{\\sqrt{\\operatorname{Pr}[x \\mid \\psi]}} \\Pi_x\\left|\\psi\\right&gt;=\\frac{\\Pi_x\\left|\\psi\\right&gt;}{\\sqrt{\\left\\langle\\psi\\left|\\Pi_x\\right| \\psi\\right\\rangle}}\\)</li> </ul> </li> </ul>"},{"location":"qip1/ch1b.html","title":"Chapter 1b: Usefull Toolbox","text":""},{"location":"qip1/ch1b.html#16-bloch-sphere","title":"1.6. Bloch Sphere:","text":"<ul> <li>Because in my class there are a lot of non-physicists I thought it would be useful to introduce the concept of the Bloch Sphere. </li> <li>Bloch Sphere is just a common representation of a two level system, which allows one to think about the states and operations in a more intuitive way</li> <li>Normally when one thinks about how many parameters one needs to define a two level system, they can naively thing 4. In the end two level system lives in \\(\\left|\\psi\\right&gt; \\in \\mathbb{C}^2\\). In different words, any pure state can be written as a superposition of the basis vectors \\(\\left|0\\right&gt;\\) and \\(\\left|1\\right&gt;\\), where the coefficient of each of the two basis vectors is a complex number. \\(\\left|\\psi\\right&gt; = a_1e^{i\\theta_1} \\left|0\\right&gt; +  a_2e^{i\\theta_2} \\left|1\\right&gt;\\). 4-parameters right?<ul> <li>We know, however, that the norm of a pure state must equal to 1, which means that $\\left&lt;\\psi|\\psi\\right&gt; = 1 $, and so \\(\\left|a_1\\right|^2 + \\left|a_2\\right|^2=1\\). This reduces the number of free parameters to 3</li> <li>We also know that we dont care about the global phase of a state, as it doesn't change anything about our measurement, and so we can also neglect one degree of freedom, which reduces the number of free parameters to 2</li> <li>This means that we can represent any 2-level quantum pure state on a unit sphere, which we will call Bloch Sphere</li> </ul> </li> <li>How does one parametrise something on a unit-sphere?<ul> <li>One can do it with angles, \\(\\theta \\text{ and } \\phi\\)</li> <li>\\(\\left|\\psi\\right&gt; = \\cos\\frac{\\theta}{2} \\left|0\\right&gt; +  e^{i\\phi}\\sin{\\frac{\\theta}{2}} \\left|1\\right&gt;\\)</li> <li>In such representation the probability of measuring state \\(\\left|0\\right&gt;\\) is: \\(\\left&lt;0|\\psi\\right&gt; = \\cos^2\\frac{\\theta}{2}\\), and to measure state \\(\\left|1\\right&gt;\\) is \\(\\sin^2\\frac{\\theta}{2}\\)</li> <li>\\(\\left|\\psi\\right&gt;\\) can be represented on a unit sphere as:</li> </ul> </li> </ul> <p>  - Any Unitary Operator then will be some sort of rotation of this state, mapping it from one point on this sphere to another point on this sphere - you will see it in the subchapter Quantum Circuits</p>"},{"location":"qip1/ch1b.html#17-bell-basis","title":"1.7. Bell Basis","text":"<ul> <li>Let \\(\\mathcal{H}_{A B}=\\mathcal{H}_A \\otimes \\mathcal{H}_B \\cong \\mathbb{C}^4\\) be the bipartite Hilbert space of two qubits and consider the product basis of the computational bases of the qubit subsystems. For \\(\\mathcal{H_{AB}}\\) there exists a basis consisting of maximally entangled states denotes as:</li> </ul> \\[\\begin{array}{ll}\\left|\\psi^{00}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|00\\right&gt;+\\left|11\\right&gt;) &amp; =\\left|\\Phi^{+}\\right&gt; \\\\ \\left|\\psi^{01}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|00\\right&gt;-\\left|11\\right&gt;) &amp; =\\left|\\Phi^{-}\\right&gt; \\\\ \\left|\\psi^{10}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|01\\right&gt;+\\left|10\\right&gt;) &amp; =\\left|\\Psi^{+}\\right&gt; \\\\ \\left|\\psi^{11}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|01\\right&gt;-\\left|10\\right&gt;) &amp; =\\left|\\Psi^{-}\\right&gt;\\end{array}\\] <ul> <li>The first number stands for parity, the second number stands for phase. \\(\\left|\\psi^{10}\\right&gt;\\) has parity 1 (odd number of 1's), and relative phase \\((-1)^0=1\\)</li> <li>The maximally entangled states are locally convertible - there exist local operations on the subsystem B that transforms one Bell state into another Bell state. \\(\\(\\left|\\psi^{i j}\\right&gt;=\\left(\\mathbb{I}_A \\otimes X_B^i Z_B^j\\right)\\left|\\psi^{00}\\right&gt;\\)\\)</li> </ul>"},{"location":"qip1/ch1b.html#18-quantum-circuits","title":"1.8. Quantum Circuits","text":"<p>Example Quantum circuit</p> <p> </p> <p>corresponds to unitary operator \\(\\left(V \\otimes \\mathbb{I}\\right)\\left(\\mathbb{I}\\otimes U\\right)\\left(H\\otimes\\mathbb{I}\\otimes Z\\right)\\) applied to three qubits followed by a Z-measurement of the first qubit</p> <p>Common Gates</p> <ul> <li>Haddamard Gate:<ul> <li>\\(H=\\frac{1}{\\sqrt{2}}\\left(\\begin{array}{cc}1 &amp; 1 \\\\ 1 &amp; -1\\end{array}\\right)=\\left|+\\right&gt;\\left&lt; 0\\right|+\\left|-\\right&gt; \\left&lt;1\\right|=\\left| 0\\right&gt;\\left&lt;+\\right|+\\left| 1\\right&gt;\\left&lt;-\\right|\\)</li> <li>As an orthogonal transformation in the real Euclidean plane \\(\\mathbb{R}^2\\), H is reflection in the mirror line at angle \\(\\frac{\\pi}{8}\\) to the x-axis  </li> </ul> </li> <li>X, Y, Z:<ul> <li>\\(X = \\left(\\begin{array}{ll} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{array}\\right)\\), \\(Z = \\left(\\begin{array}{ll} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{array}\\right)\\), \\(Y = \\left(\\begin{array}{ll} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{array}\\right)\\)</li> <li>X-gate</li> <li> </li> <li>Y-gate</li> <li> </li> <li>Z-gate</li> <li> </li> </ul> </li> <li>Controlled-U Gate:<ul> <li>\\(\\mathrm{C} U=\\left|0\\right&gt;\\left&lt;0\\right|\\otimes \\mathrm{id}+\\left| 1\\right&gt;\\left&lt;1\\right| \\otimes U\\)</li> </ul> </li> <li>Controlled-Not Gate:<ul> <li>\\(\\mathrm{CNOT}=\\left(\\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)=\\left|0 \\right&gt;\\left&lt; 0\\right| \\otimes \\mathbb{I}+\\left|1\\right&gt;\\left&lt;1\\right| \\otimes X\\)</li> </ul> </li> </ul>"},{"location":"qip1/ch2a.html","title":"Chapter 2a: Computational Complexity:","text":"<p>I will start first by introducing the ideas from the classical computations, and then I will try to extend it to quantum computation and then try to observe the difference. </p> <p>Computational task is usually general i.e. 'given an n-bit string A (for any n), is A prime?'. Studying information theory, we are interested to know how efficient our computation is and whether allowing for some new quantum properties we will improve this computational efficiency. How efficient algorithm is can be measured though algorithm complexity.</p>"},{"location":"qip1/ch2a.html#21-algorithm-complexity","title":"2.1. Algorithm Complexity:","text":"<p>How efficient an algorithm is, can be measured in the amount of resources that are needed to solve a problem of size n.</p> <ul> <li>Time complexity deals with the number of computational steps required for solving the problem</li> <li>Space complexity deals with the amount of RAM that is needed to solve the problem</li> </ul> <p>Big O-Notation is very handy in this case - to easily compare two algorithms</p>"},{"location":"qip1/ch2a.html#22-big-o-notation","title":"2.2. Big O notation:","text":"<p>Below I included definitions from P.Kammerlander lecture, for more intuitive picture go directly to the grey box:</p> <ul> <li> <p>\\(f(n)=o(g(n))\\) and say that \\(f\\) grows slower than \\(g\\) if \\(\\forall c&gt;0 \\exists n_0&gt;0\\) such that for all \\(n \\geq n_0: f(n) \\leq c g(n)\\),</p> </li> <li> <p>\\(f(n)=O(g(n))\\) and say that \\(f\\) does not grow significantly faster than \\(g\\) if \\(\\exists c&gt;0\\) and \\(n_0&gt;0\\) such that for all \\(n \\geq n_0: f(n) \\leq c g(n)\\),</p> </li> <li> <p>\\(f(n)=\\Omega(g(n))\\) and say that \\(f\\) does not grow significantly slower than \\(g\\) if \\(\\exists c&gt;0\\) and \\(n_0&gt;0\\) such that for all \\(n \\geq n_0: c g(n) \\leq f(n)\\),</p> </li> <li> <p>\\(f(n)=\\Theta(g(n))\\) and say that \\(f\\) grows as fast as \\(g\\) if both \\(f(n)=O(g(n))\\) and \\(f(n)=\\Omega(g(n))\\).</p> </li> </ul> <p>Formally, define \\(f(n)=O(g(n))\\) provided \\(|f(n)| \\leq c|g(n)|\\) as \\(n \\rightarrow \\infty\\) - \\(|f(n)|\\) is bounded for some constant \ud835\udc50 and all su\ufb00iciently large \ud835\udc5b. - Intuitively, look at the most significant term. - Ignore constant factors as they seldom dominate and are often transitory</p> <p>For example: consider \\(\ud835\udc5b^2\\) instead of \\(3\ud835\udc5b^2 + 34\ud835\udc5b + 433\\): - The cost of a program is usually a complicated formula. Often we should consider only the most significant term. If the cost is \\(\ud835\udc5b^2 + 99\ud835\udc5b + 900\\) for an input of size \\(\ud835\udc5b\\), then the \\(\ud835\udc5b^2\\) term will eventually dominate, even though \\(99\ud835\udc5b\\) is bigger for \\(\ud835\udc5b &lt; 99\\). The constant term 900 may look big, but it is soon dominated by \\(\ud835\udc5b^2\\).</p> <p>i.e. We don't care in this case whether each time-step will take 1minute or 1ms, as for sufficiently large problem it wont matter. If we can make the algorithm more efficient, there will exist a n, for which the slow computer will be solving problem of size n faster.</p> <p>Simple Facts about O Notation:</p> <ul> <li>\\(\\begin{array}{r}O(2 g(n)) \\text { is the same as } O(g(n)) \\\\ O\\left(\\log _{10} n\\right) \\text { is the same as } O(\\ln n) \\\\ O\\left(n^2+50 n+36\\right) \\text { is the same as } O\\left(n^2\\right) \\\\ O\\left(n^2\\right) \\text { is contained in } O\\left(n^3\\right) \\\\ O\\left(2^n\\right) \\text { is contained in } O\\left(3^n\\right) \\\\ O(\\log n) \\text { is contained in } O(\\sqrt{n})\\end{array}\\)</li> </ul> <p>Above is taken from [4]</p>"},{"location":"qip1/ch2a.html#23-complexity-classes","title":"2.3. Complexity Classes:","text":"<p>Decision Problem is a problem that can be formulated as a yes-no question of the input value. </p> <p>Zoo of Complexity Classes</p> <ul> <li>P: (Polynomial) The class of decision problems that can be solved in polynomial time on a classical computer.</li> <li>BPP: (Bounded-Error probabilistic polynomial time) The class of decision problems that can be solved by a probabilistic algorithm in polynomial time on a classical computer with failure probability at most \\(\\frac{1}{3}\\) for all possible inputs.</li> <li>NP: The class of decision problems such that, if the answer is \u2018yes\u2019, there is a proof of this which can be verified in polynomial time on a classical computer.</li> <li>PSPACE: (Space complexity polynomial) The class of decision problems that can be solved in polynomial space on a classical computer.</li> <li>NP-complete: A problem is said to be NP-complete if it is in NP and any other problem in NP can be reduced to it in polynomial time.</li> <li>BQP: The class of decision problems that can be solved in polynomial time on a quantum computer with failure probability at most \\(\\frac{1}{3}\\) for all possible inputs.</li> </ul> <p>Some facts:</p> <ul> <li>\\(\\mathbf{P} \\subset \\mathbf{B P P}\\)</li> <li>\\(\\mathbf{P} \\subset \\mathbf{N P} \\subset \\mathbf{P S P A C E}\\)</li> <li>It is not known whether \\(\\mathbf{B P P} \\subset \\mathbf{N P}\\)</li> <li>Factorisation is not known and not believed to be NP-complete</li> <li>We dont know whether \\(\\mathbf{P} = \\mathbf{B P P}\\), although many believe so</li> </ul>"},{"location":"qip1/ch2a.html#24-quantum-complexity","title":"2.4. Quantum Complexity","text":"<p>For quantum computers we need to somehow define the operation. Quantum computation is simply application of some unitary operator \\(U \\in \\mathcal{U}(2^n)\\) to some initial state of n qubit (usually \\(\\left|0\\right&gt;=\\left|00 \\cdots 0\\right&gt;=\\left|0^n\\right&gt;=\\left|0\\right&gt;^{\\otimes n}\\)), followed by a measurement m of the qubits in the computational basis. Any \\(U \\in \\mathcal{U}(2^n)\\) is composed of an elementary gate from \\(\\mathcal{S}\\).</p> <ul> <li>circuit size is the number of elementary gates</li> <li>circuit width is the number of s-qubits that are involved in those elementary gates</li> <li>circuit depth is the number of actual time steps needed while allowing for parallel execution of elementary gates on di\u2000erent qubits. However, the depth di\u2000ers from the size at most by a constant factor of s and is hence not relevant for the asymptotic runtime.</li> </ul>"},{"location":"qip1/ch2b.html","title":"Chapter 2b: Universal gates, Reversible irreversability, DJ algorithm","text":""},{"location":"qip1/ch2b.html#25-universal-sets-of-gates","title":"2.5. Universal sets of gates","text":"<ul> <li>\\(\\mathcal{S}\\) is universal set of gates for quantum computing if for any \\(n \\in \\mathbb{N}\\) an arbitrary unitary operation \\(U \\in \\mathcal{U}(n)\\) can be implemented to arbitrary precision using only elementary gates from \\(\\mathcal{S}\\)</li> <li>Elementary gates are assumed to take time \\(O(1)\\)</li> <li>Examples of the universal set of gates:<ul> <li>\\(\\{CNOT\\} \\cup \\mathcal{U}(2)\\)</li> <li>\\(\\{CNOT, H, T\\}\\)</li> <li>\\(\\{\\text{Toffoli}, H\\}\\)</li> </ul> </li> <li>For any fixed universal set \\(\\mathcal{S}\\), a generic unitary matrix on n qubits requires exponentially many elementary gates n to be implemented - this follows from the fact that an n-qubit unitary is determined by \\(O(4^n)\\) real parameters</li> <li>Goal of quantum computing is to find efficient quantum circuits which use poly(n) qubits and poly(n) elementary gates to solve a problem on an input size n</li> </ul>"},{"location":"qip1/ch2b.html#26-simulating-classical-circuits-leftmathbfb-p-p-subset-mathbfb-q-pright","title":"2.6. Simulating Classical Circuits \\(\\left(\\mathbf{B P P} \\subset \\mathbf{B Q P}\\right)\\)","text":"<ul> <li>A classical circuit is a sequence of logical operations that act on a small number of bits (AND, OR, NOT)</li> <li>We claim that quantum computation is at least as powerfull as classical computation \\(\\mathbf{B P P} \\subset \\mathbf{B Q P}\\)</li> <li>Difficulty arises when trying to translate irreversible logical operations such as AND or OR. Quantum operations are unitary, hence reversible. This poses a problem.</li> <li>The crucial step in showing that one can simulate any classical circuit with a quantum circuit involves showing that any classical boolean operation (even irreversible) can be represented through reversible operation on larger space</li> <li>The key point is that if we operate with unitaries on a larger space, but we only look at the subspace, it will look like the operation is non-unitary, (irreversible)</li> <li>If \\(f: B_m \\rightarrow B_n\\) is a Boolean function it can be expressed in an equivalent reversible form \\(\\tilde{f}: B_{m+n} \\rightarrow B_{m+n}\\).<ul> <li>to do this we introduce an addition operation \\(\\oplus\\), which is operation of adding mod 2</li> <li>for any \\(f: B_m \\rightarrow B_n\\) define \\(\\tilde{f}:B_{m+n}\\rightarrow B_{m+n}\\), where \\(\\tilde{f}(b, c)=(b, c \\oplus f(b))\\)</li> <li>such function is reversible, as applying the function twice results in \\((b, c \\oplus f(b) \\oplus f(b)) = (b, c \\oplus 0...0) = (b, c)\\)</li> <li>it performs the wanted operation, because if c is initialised with \\(c=0...0\\), then \\(\\tilde{f}(b, c) = (b, f(b))\\)</li> </ul> </li> <li>By replacing all (now reversible) classical gates with quantum gates and imputing computation basis states, one can obtain quantum circuit that simulates the classical one </li> </ul>"},{"location":"qip1/ch2b.html#27-oracle-for-boolean-function","title":"2.7. Oracle for Boolean function:","text":"<ul> <li>A quantum oracle for any Boolean function \\(f:B_n\\rightarrow B_m\\) will be the quantum gate denoted \\(O_f\\) on \\(n+m\\) qubits defined by its action on basis states as follows  $$ O_f\\left|x\\right&gt;\\left|y\\right&gt;=\\left|x\\right&gt;\\left|y \\oplus f(x)\\right&gt; \\quad \\text { for all } x \\in B_n \\text { and } y \\in B_m $$</li> <li>Sometimes we refer to n-qubit register \\(\\left|x\\right&gt;\\) and the m-qubit register \\(\\left|y\\right&gt;\\) as the input and output registers respectively</li> <li> <p>A phase oracle will be quantum gate denoted \\(U_f\\) on \\(n+m\\) qubits defined by its action on basis states as follows  $$ U_f\\left|x\\right&gt;=(-1)^{f(x)}\\left|x\\right&gt; $$</p> </li> <li> <p>This can be achieved through \\(O_f\\) $$ O_f\\left|-\\right&gt;\\left|x\\right&gt;=O_f \\frac{1}{\\sqrt{2}}(\\left|0\\right&gt;-\\left|1\\right&gt;)\\left|x\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|f(x)\\right&gt;\\left|x\\right&gt;-\\left|1 \\oplus f(x)\\right&gt;\\left|x\\right&gt;)=(-1)^{f(x)}\\left|-\\right&gt;\\left|x\\right&gt; $$</p> </li> </ul>"},{"location":"qip1/ch2b.html#28-deutsch-josza-dj-algorithm","title":"2.8. Deutsch-Josza (DJ) algorithm:","text":"<ul> <li>Problem: Given a function \\(f : \\{0,1\\}^n \\rightarrow \\{0, 1\\}\\) with a promise that a function is either constant or balanced the goal is to find out whether \\(f\\) is constant or balanced. Balanced means that it outputs 0 half of the time and 1 the other half of the time. Constant means that it always outputs the same thing (either 1 or 0).</li> <li>Classical algorithm will require exponentially many queries to \\(f\\), namely \\(2^{n-2}\\) on average</li> <li>Quantum algorithm is able to determine whether f is constant or balanced in a single query</li> <li>Algorithm:<ul> <li></li> <li>Which corresponds to \\(H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n}\\)</li> <li>We then evaluate the probability of \\(y = 0^n\\), which is equivalent to projecting the state onto \\(\\left|0\\right&gt;^{\\otimes n}\\)</li> <li>\\(\\left&lt;0\\right|^{\\otimes n}H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n} = \\begin{cases}1, &amp; \\text { if } f \\text { is constant } \\\\ 0, &amp; \\text { if } f \\text { is balanced }\\end{cases}\\) </li> </ul> </li> <li>Explanation 1:<ul> <li>Because we have equal superposition of all x-values, then if \\(U_f\\) is balanced then they will all add up to 0, and if they are constant, they will add up to 1</li> </ul> </li> </ul> \\[ \\left&lt;0\\right|^{\\otimes n}H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n} = \\left(\\frac{1}{\\sqrt{2^n}} \\sum_{x \\in\\{0,1\\}^n}\\left&lt;x\\right|\\right) U_f \\left(\\frac{1}{\\sqrt{2^n}} \\sum_{x' \\in\\{0,1\\}^n}\\left|x'\\right&gt;\\right) = \\frac{1}{2^n} \\sum_{x \\in\\{0,1\\}^n}\\left&lt;x\\right| U_f \\left|x\\right&gt; \\]"},{"location":"qip1/organisation.html","title":"Organisation","text":""},{"location":"qip1/organisation.html#group-chat","title":"Group Chat:","text":""}]}