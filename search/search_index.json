{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Abstract","text":"<p>Thoughts are fleeting, and to keep them from slipping away, the author attempted to capture them in writing. Both silly and more serious thoughts were recorded. It became apparent that, while writing, the author gained a slightly better understanding of the topics at hand. Whether readers find it enjoyable remains to be seen.</p>"},{"location":"qip1/ch0.html","title":"Chapter 0: Introduction","text":"<p>My plan is to share my edited notes that I made whilst preparing for the teaching. I am doing it mainly in order to make sure I understand the topics, and motivate myself to be clear with explanations. I hope to give different intuition, which perhaps will be useful to some. </p> <p>In case of any queries and feedback, don't hesitate to contact me (wadamczyk@phys.ethz.ch)</p> <p>Resources: Which I used to write my notes - There is a lot of re-writing and paraphrasing, which I havent cited next to the sentence (the nature of notes)</p> <ul> <li>Principles of Quantum Mechanics (David Skinner) [1]</li> <li>Quantum Information Processing (J.P.Home) [2]</li> <li>Quantum Information and Computation (Richard Jozsa) [3]</li> <li>Foundations of Computer Science (Anil Madhavapeddy, Jonathan Ludlam) [4]</li> <li>Quantum Information (C.H.W. Barnes) [5]</li> </ul>"},{"location":"qip1/ch0.html#chapter-0-introduction","title":"Chapter 0: Introduction","text":"<p>Computation is about manipulation of information. Mathematically we can ponder on the different abstract schemes and systems to manipulate information, however, in practice we are very limited to what type of computation can we really do. \"Information is not a disembodied abstract entity; it is always tied to a physical representation\". [3] \"If information is represented in physical states or degrees of freedom of some physical system, then any possible act of computation, or information processing, must correspond to a physical evolution of that physical system.\" [3] This means that the rules of the computation must obey the laws of physics.</p> <p>Current paradigm of computing relies on classical physics, which in result constrains what operations can we perform on the computers. \"But that is not our World. To the best of our current experimental knowledge, our World is a quantum, not classical.\" [1] This gives us hope. If one carefully isolates and always consideres the whole system, we could enlarge the zoo of the operations we could perform. Extra tools could lead to different complexity classes of the algorithms that were previously not solvable by classical computers, and could aid in further understanding of the world. </p> <p>QIP-Implementation intends to show how can we build systems that can manipulate information using laws of quantum physics. QIP-Concepts intends to entertain the idea that we have the possibility of treating the information in a quantum way. We want to give you the grounding of exploring for yourself how does this change the paradigm of computation.</p> <p>In my notes I will largely \"ignore small formal subtleties, not because they're not interesting, but because they're a distraction from all the interesting physics we want to learn!\" [1]. I will actually skip some of the formalism introduced in the lecture if I feel like it hinders my own understanding of Quantum Mechanics. I am open to being criticised for it. </p>"},{"location":"qip1/ch0.html#chapter-01-why-do-we-care-about-quantum-computing","title":"Chapter 0.1: Why do we care about Quantum Computing","text":"<p>...</p>"},{"location":"qip1/ch1a.html","title":"Chapter 1a: Principles of Quantum Mechanics","text":""},{"location":"qip1/ch1a.html#11-hilbert-spaces","title":"1.1. Hilbert spaces:","text":"<p>Hilbert Space:</p> <ul> <li>Hilbert space is a vector space \\(\\mathcal{H}\\) over \\(\\mathbb{C}\\) that is equipped with a complete inner product. </li> <li>This definition has 3 keywords: <ul> <li>Vector space - is well known, </li> <li>Complete - is just a hedge against infinite Hilbert Spaces (unimportant)</li> <li>Inner Product is a map \\((\\quad,\\quad): \\mathcal{H} \\times \\mathcal{H} \\rightarrow \\mathbb{C}\\) that obeys</li> </ul> </li> </ul> \\[ \\begin{aligned} \\text { conjugate symmetry } &amp; (\\phi, \\psi)=\\overline{(\\psi, \\phi)} \\\\ \\text { linearity } &amp; (\\phi, a \\psi)=a(\\phi, \\psi) \\\\ \\text { additivity } &amp; (\\phi, \\psi+\\chi)=(\\phi, \\psi)+(\\phi, \\chi) \\\\ \\text { positive-definiteness } &amp; (\\psi, \\psi) \\geq 0 \\forall \\psi \\in \\mathcal{H} \\end{aligned} \\] <ul> <li>Metric of \\(\\mathcal{H}\\) is defined by the norm \\(\\|\\psi\\| \\equiv \\sqrt{(\\psi, \\psi)}\\)</li> <li>Quantum states can be represented as a vectors \\(\\psi \\in \\mathcal{H}\\)</li> </ul> <p>Dual Spaces:</p> <ul> <li>Dual space \\(\\mathcal{H^*}\\) of a \\(\\mathcal{H}\\) is the space of linear maps \\(\\mathcal{H} \\rightarrow \\mathbb{C}\\). That is, an element \\(\\phi \\in \\mathcal{H^*}\\) defines a map \\(\\varphi: \\psi \\mapsto \\varphi(\\psi) \\in \\mathbb{C}\\) for every \\(\\psi \\in \\mathcal{H}\\), such that </li> </ul> \\[ \\varphi: a \\psi_1+b \\psi_2 \\mapsto a \\varphi\\left(\\psi_1\\right)+b \\varphi\\left(\\psi_2\\right) \\] <ul> <li>One of the dual space \\(\\mathcal{H^*}\\) is for instance the inner product \\((\\phi, \\quad) \\in \\mathcal{H}^*\\) for \\(\\phi \\in \\mathcal{H}\\), where </li> </ul> \\[ (\\phi, \\quad): \\psi \\mapsto(\\phi, \\psi) \\]"},{"location":"qip1/ch1a.html#12-dirac-notation","title":"1.2. Dirac Notation:","text":"<p>In quantum mechanics quite often we often switch basis. This is because intrinsically any measurement causes a collapse onto the measurement basis. Because of this we want to have a notation that allows us to work with multiple basis at the same time, and not get confused. Dirac notation (empirically) provides this clarity. It is difficult to formally define the notation, and quite often when one does it, they get confused (unless they are deep down in theory). Therefore I would propose to learn it through learning the basic few properties and then trying things out. </p> <p>Dirac denotes element of \\(\\mathcal{H}\\) as \\(\\left|\\psi\\right&gt;\\) 'ket', and an element of the dual space is written as \\(\\mathcal{H^*}\\) as \\(\\left&lt;\\psi\\right|\\) 'bra'. The inner product between two states \\(\\left|\\psi\\right&gt;, \\left|\\phi\\right&gt; \\in \\mathcal{H}\\) is written as \\(\\left&lt;\\psi|\\phi\\right&gt;\\).</p> <p>In notes the bra-ket notation is introduced using homomorphisms (linear maps). I find it unecessary.</p> <ul> <li>The advantage of using bra-ket notation is:<ul> <li>We can talk about multiple things at the same time - Dirac notation is effectively just a label that points to an abstract object in the Hilbert space. We don't need to specify whether the variable is contineous, or if it is a vector or a function.</li> <li>Allows us to label states by their eigenvalues</li> <li>Somehow it is more natural and causes less confusion</li> </ul> </li> </ul>"},{"location":"qip1/ch1a.html#13-operators","title":"1.3. Operators:","text":"<ul> <li>A linear operator A is a map \\(A : \\mathcal{H} \\rightarrow \\mathcal{H}\\) that is compatible with the vector space structure \\(A(c_1\\left|\\phi_1\\right&gt; + c_2\\left|\\phi_2\\right&gt;) = c_1A\\left|\\phi_1\\right&gt; + c_2A\\left|\\phi_2\\right&gt;\\)</li> <li>All operators in Quantum Mechanics are linear, hence we will call them just 'operators'</li> <li>Operators form algebra<ul> <li>Sum: \\((\\alpha A+\\beta B):\\left|\\phi\\right&gt; \\mapsto \\alpha A\\left|\\phi\\right&gt;+\\beta B\\left|\\phi\\right&gt;\\)</li> <li>Product: \\(A B: \\phi \\mapsto A \\circ B\\left|\\phi\\right&gt;=A(B\\left|\\phi\\right&gt;)\\)</li> <li>Commutator: \\([A, B]=A B-B A\\)</li> </ul> </li> <li>A state \\(\\psi \\in \\mathcal{H}\\) is said to be an eigenstate of an operator A if \\(A\\left|\\psi\\right&gt; = a_\\psi\\left|\\psi\\right&gt;\\) with an associated eigenvalue '\\(a_\\psi\\)'.</li> <li>Adjoint \\(A^\\dagger\\) of an operator \\(A\\) is defined as \\(\\left&lt;\\phi\\right|A^{\\dagger}\\left| \\psi\\right&gt;=\\overline{\\left&lt;\\psi\\right|A\\left| \\phi\\right&gt;} \\quad\\)</li> <li>An operator \\(Q\\) is called Hermitian if \\(Q^\\dagger=Q\\)</li> <li>An operator \\(U\\) is called Unitary if \\(U^\\dagger U= U U^\\dagger = \\mathbb{I}\\)</li> <li>An operator \\(\\Pi\\) is called Projector if \\(\\Pi\\Pi= \\Pi\\)</li> </ul>"},{"location":"qip1/ch1a.html#14-composite-systems","title":"1.4. Composite systems:","text":"<p>Tensor Product</p> <ul> <li>Tensor product \\(\\mathcal{H}_1 \\otimes \\mathcal{H}_2\\) is a vector space over \\(\\mathbb{C}\\) spanned by all pairs of elements \\(\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\), where \\(\\left|e_a\\right&gt; \\in \\mathcal{H_1}\\), \\(\\left|f_\\alpha\\right&gt; \\in \\mathcal{H_2}\\)</li> <li>It is not true that a general element of \\(\\mathcal{H}_1 \\otimes \\mathcal{H}_2\\) necessarily takes the form \\(\\left|\\psi_1\\right&gt;\\otimes\\left|\\psi_2\\right&gt;\\)</li> <li>Rahter, a general element may be written as \\(\\left|\\Psi\\right&gt;=\\sum_{a, \\alpha} r_{a \\alpha}\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\)</li> <li>Elements of the form \\(\\left|\\psi_1\\right&gt;\\otimes\\left|\\psi_2\\right&gt;\\) are called simple, and the elements of the form \\(\\left|\\Psi\\right&gt;=\\sum_{a, \\alpha} r_{a \\alpha}\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\) are refered as entangled</li> <li>\\(\\left&lt;\\alpha\\otimes\\beta|\\alpha'\\otimes\\beta'\\right&gt; := \\left&lt;\\alpha|\\alpha'\\right&gt;\\left&lt;\\beta|\\beta'\\right&gt;\\)</li> <li>\\(\\left( S_\\alpha \\otimes T_\\beta \\right)\\left(\\alpha \\otimes \\beta\\right) = \\left(S_\\alpha\\alpha\\right)\\otimes\\left(T_\\beta\\beta\\right)\\) - apologies for being slightly sloppy - I think it is understandable what I mean though</li> </ul> <p>Tensor Product in action (states)</p> <ul> <li>Let's as an example consider that our states \\(\\left|\\alpha\\right&gt;_A \\text{ and } \\left|\\beta\\right&gt;_B\\) live both in \\(\\mathbb{C}^2_A\\) and \\(\\mathbb{C}^2_B\\) respectively. Then we can pick orthonormal basis of \\(\\mathbb{C}^2_A\\) to be \\(\\left\\{\\left|u_1\\right&gt;_A, \\left|u_2\\right&gt;_A \\right\\}\\), and of \\(\\mathbb{C}^2_B\\) to be \\(\\left\\{\\left|v_1\\right&gt;_B, \\left|v_2\\right&gt;_B \\right\\}\\)</li> <li>Then one can write \\(\\left|\\alpha\\right&gt;_A = a_1 \\left|u_1\\right&gt;_A + a_2 \\left|u_2\\right&gt;_A = a_1 \\begin{pmatrix} 1\\\\ 0 \\end{pmatrix}_A + a_2 \\begin{pmatrix} 0\\\\ 1 \\end{pmatrix}_A\\),</li> <li>and \\(\\left|\\beta\\right&gt;_B = b_1 \\left|v_1\\right&gt;_B + b_2 \\left|v_2\\right&gt;_B = b_1 \\begin{pmatrix} 1\\\\ 0 \\end{pmatrix}_B + b_2 \\begin{pmatrix} 0\\\\ 1 \\end{pmatrix}_B\\)</li> <li>This means that one can write </li> </ul> \\[ \\left|\\alpha\\right&gt;_A \\otimes \\left|\\beta\\right&gt;_B = \\begin{pmatrix} a_1\\\\ a_2 \\end{pmatrix}_A \\otimes \\begin{pmatrix} b_1\\\\ b_2 \\end{pmatrix}_B = \\begin{pmatrix} a_1b_1\\\\ a_1b_2\\\\ a_2b_1\\\\ a_2b_2 \\end{pmatrix} \\] <ul> <li>or sticking to the Dirac notation:</li> </ul> \\[ \\left|\\alpha\\right&gt;_A \\otimes \\left|\\beta\\right&gt;_B = \\sum_{i,j} a_i b_j \\left|u_i\\right&gt;_A \\otimes \\left|v_j\\right&gt;_B \\] <p>Tensor Product in action (operators)</p> <ul> <li>For operators \\(A\\) and \\(B\\) that live in \\(\\mathbb{C}^2_A\\) and \\(\\mathbb{C}^2_B\\) respectively, one can write \\(A = \\sum_{i,j} a_{ij} \\left|u_i\\right&gt;_A \\left&lt;u_j\\right|\\) and \\(B = \\sum_{i,j} b_{ij} \\left|v_i\\right&gt;_B \\left&lt;v_j\\right|\\)</li> <li>This means:</li> </ul> \\[ A \\otimes B = \\sum_{i,j,k,\\ell} a_{ij} b_{k\\ell} \\left|u_i\\right&gt;_A \\otimes \\left|v_k\\right&gt;_B \\left&lt;u_j\\right|\\otimes\\left&lt;v_\\ell\\right| \\] <ul> <li>or in a matrix form:</li> </ul> \\[ A \\otimes B = \\begin{pmatrix} a_{11}B &amp; a_{12}B\\\\ a_{21}B &amp; a_{22}B \\end{pmatrix} = \\begin{pmatrix} a_{11}b_{11} &amp; a_{11}b_{12} &amp; a_{12}b_{11} &amp; a_{12}b_{12}\\\\ a_{11}b_{21} &amp; a_{11}b_{22} &amp; a_{12}b_{21} &amp; a_{12}b_{22}\\\\ a_{21}b_{11} &amp; a_{21}b_{12} &amp; a_{22}b_{11} &amp; a_{22}b_{12}\\\\ a_{21}b_{21} &amp; a_{21}b_{22} &amp; a_{22}b_{21} &amp; a_{22}b_{22}\\\\ \\end{pmatrix} \\]"},{"location":"qip1/ch1a.html#15-postulates-of-quantum-mechanics","title":"1.5. Postulates of Quantum Mechanics:","text":"<ul> <li>(1) A quantum system A is associated with complex Hilber space \\(\\mathcal{H}\\). A physical state of an isolated system is represented by a normalised vector \\(\\left|\\psi\\right&gt; \\in \\mathcal{H}\\), which is unique up to a phase factor</li> <li>(2) The evolution of an isolated quantum system is reversible. In this formalism this corresponds to unitary evolution of the form \\(\\left|\\psi\\right&gt; \\mapsto U\\left|\\psi\\right&gt;\\) for \\(U \\in \\mathcal{U}(\\mathcal{H})\\), i.e. \\(U^{\\dagger} U=U U^{\\dagger}=\\mathbb{I}\\). The unitary is unique up to a phase factor</li> <li>(3) Composite system - For two quantum system A, and B with associated Hilber spaces \\(\\mathcal{H_A}\\) and \\(\\mathcal{H_B}\\) the Hilbert space \\(\\mathcal{H_{AB}}\\) associated with the composite system AB is isomorphic to the tensor product \\(\\mathcal{H_A}\\otimes\\mathcal{H_B}\\). For unitary operation on the subsystem we use: \\(U_A \\otimes \\mathbb{I}_B\\left|i j\\right&gt;_{A B} \\equiv U_A\\left|i j\\right&gt;_{A B}\\)</li> <li>(4) Measurement - A projective measurement on a quantum system with outcomes labelled \\({x}_x\\) is associated with a set of projectors \\({\\Pi_x}x\\) satisfying \\(\\sum_x \\Pi_x = \\mathbb{I}\\). <ul> <li>Probability of getting outcome x when measuring state \\(\\left|\\psi\\right&gt;\\) is given by the Born rule: \\(Pr[x \\mid \\psi]=\\left\\langle\\psi\\left|\\Pi_x\\right| \\psi\\right\\rangle\\)</li> <li>Post-measurement state is given the outcome x is \\(\\left|\\psi_x^{\\prime}\\right&gt;=\\frac{1}{\\sqrt{\\operatorname{Pr}[x \\mid \\psi]}} \\Pi_x\\left|\\psi\\right&gt;=\\frac{\\Pi_x\\left|\\psi\\right&gt;}{\\sqrt{\\left\\langle\\psi\\left|\\Pi_x\\right| \\psi\\right\\rangle}}\\)</li> </ul> </li> </ul>"},{"location":"qip1/ch1b.html","title":"Chapter 1b: Usefull Toolbox","text":""},{"location":"qip1/ch1b.html#16-bloch-sphere","title":"1.6. Bloch Sphere:","text":"<ul> <li>Because in my class there are a lot of non-physicists I thought it would be useful to introduce the concept of the Bloch Sphere. </li> <li>Bloch Sphere is just a common representation of a two level system, which allows one to think about the states and operations in a more intuitive way</li> <li>Normally when one thinks about how many parameters one needs to define a two level system, they can naively thing 4. In the end two level system lives in \\(\\left|\\psi\\right&gt; \\in \\mathbb{C}^2\\). In different words, any pure state can be written as a superposition of the basis vectors \\(\\left|0\\right&gt;\\) and \\(\\left|1\\right&gt;\\), where the coefficient of each of the two basis vectors is a complex number. \\(\\left|\\psi\\right&gt; = a_1e^{i\\theta_1} \\left|0\\right&gt; +  a_2e^{i\\theta_2} \\left|1\\right&gt;\\). 4-parameters right?<ul> <li>We know, however, that the norm of a pure state must equal to 1, which means that $\\left&lt;\\psi|\\psi\\right&gt; = 1 $, and so \\(\\left|a_1\\right|^2 + \\left|a_2\\right|^2=1\\). This reduces the number of free parameters to 3</li> <li>We also know that we dont care about the global phase of a state, as it doesn't change anything about our measurement, and so we can also neglect one degree of freedom, which reduces the number of free parameters to 2</li> <li>This means that we can represent any 2-level quantum pure state on a unit sphere, which we will call Bloch Sphere</li> </ul> </li> <li>How does one parametrise something on a unit-sphere?<ul> <li>One can do it with angles, \\(\\theta \\text{ and } \\phi\\)</li> <li>\\(\\left|\\psi\\right&gt; = \\cos\\frac{\\theta}{2} \\left|0\\right&gt; +  e^{i\\phi}\\sin{\\frac{\\theta}{2}} \\left|1\\right&gt;\\)</li> <li>In such representation the probability of measuring state \\(\\left|0\\right&gt;\\) is: \\(\\left&lt;0|\\psi\\right&gt; = \\cos^2\\frac{\\theta}{2}\\), and to measure state \\(\\left|1\\right&gt;\\) is \\(\\sin^2\\frac{\\theta}{2}\\)</li> <li>\\(\\left|\\psi\\right&gt;\\) can be represented on a unit sphere as:</li> </ul> </li> </ul> <p>  - Any Unitary Operator then will be some sort of rotation of this state, mapping it from one point on this sphere to another point on this sphere - you will see it in the subchapter Quantum Circuits</p>"},{"location":"qip1/ch1b.html#17-bell-basis","title":"1.7. Bell Basis","text":"<ul> <li>Let \\(\\mathcal{H}_{A B}=\\mathcal{H}_A \\otimes \\mathcal{H}_B \\cong \\mathbb{C}^4\\) be the bipartite Hilbert space of two qubits and consider the product basis of the computational bases of the qubit subsystems. For \\(\\mathcal{H_{AB}}\\) there exists a basis consisting of maximally entangled states denotes as:</li> </ul> \\[\\begin{array}{ll}\\left|\\psi^{00}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|00\\right&gt;+\\left|11\\right&gt;) &amp; =\\left|\\Phi^{+}\\right&gt; \\\\ \\left|\\psi^{01}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|00\\right&gt;-\\left|11\\right&gt;) &amp; =\\left|\\Phi^{-}\\right&gt; \\\\ \\left|\\psi^{10}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|01\\right&gt;+\\left|10\\right&gt;) &amp; =\\left|\\Psi^{+}\\right&gt; \\\\ \\left|\\psi^{11}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|01\\right&gt;-\\left|10\\right&gt;) &amp; =\\left|\\Psi^{-}\\right&gt;\\end{array}\\] <ul> <li>The first number stands for parity, the second number stands for phase. \\(\\left|\\psi^{10}\\right&gt;\\) has parity 1 (odd number of 1's), and relative phase \\((-1)^0=1\\)</li> <li>The maximally entangled states are locally convertible - there exist local operations on the subsystem B that transforms one Bell state into another Bell state. \\(\\(\\left|\\psi^{i j}\\right&gt;=\\left(\\mathbb{I}_A \\otimes X_B^i Z_B^j\\right)\\left|\\psi^{00}\\right&gt;\\)\\)</li> </ul>"},{"location":"qip1/ch1b.html#18-quantum-circuits","title":"1.8. Quantum Circuits","text":"<p>Example Quantum circuit</p> <p> </p> <p>corresponds to unitary operator \\(\\left(V \\otimes \\mathbb{I}\\right)\\left(\\mathbb{I}\\otimes U\\right)\\left(H\\otimes\\mathbb{I}\\otimes Z\\right)\\) applied to three qubits followed by a Z-measurement of the first qubit</p> <p>Common Gates</p> <ul> <li>Haddamard Gate:<ul> <li>\\(H=\\frac{1}{\\sqrt{2}}\\left(\\begin{array}{cc}1 &amp; 1 \\\\ 1 &amp; -1\\end{array}\\right)=\\left|+\\right&gt;\\left&lt; 0\\right|+\\left|-\\right&gt; \\left&lt;1\\right|=\\left| 0\\right&gt;\\left&lt;+\\right|+\\left| 1\\right&gt;\\left&lt;-\\right|\\)</li> <li>As an orthogonal transformation in the real Euclidean plane \\(\\mathbb{R}^2\\), H is reflection in the mirror line at angle \\(\\frac{\\pi}{8}\\) to the x-axis  </li> </ul> </li> <li>X, Y, Z:<ul> <li>\\(X = \\left(\\begin{array}{ll} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{array}\\right)\\), \\(Z = \\left(\\begin{array}{ll} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{array}\\right)\\), \\(Y = \\left(\\begin{array}{ll} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{array}\\right)\\)</li> <li>X-gate<ul> <li> </li> </ul> </li> <li>Y-gate<ul> <li> </li> </ul> </li> <li>Z-gate<ul> <li> </li> </ul> </li> </ul> </li> <li>Controlled-U Gate:<ul> <li>\\(\\mathrm{C} U=\\left|0\\right&gt;\\left&lt;0\\right|\\otimes \\mathrm{id}+\\left| 1\\right&gt;\\left&lt;1\\right| \\otimes U\\)</li> </ul> </li> <li>Controlled-Not Gate:<ul> <li>\\(\\mathrm{CNOT}=\\left(\\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)=\\left|0 \\right&gt;\\left&lt; 0\\right| \\otimes \\mathbb{I}+\\left|1\\right&gt;\\left&lt;1\\right| \\otimes X\\)</li> </ul> </li> </ul>"},{"location":"qip1/ch2a.html","title":"Chapter 2a: Quantum Information","text":"<p>Initially I didn't want to talk much about quantum information theory. In my mind there is another course that deals with it in much more detail (Quantum Information Theory). However, because the lecture course covers these topics, I decided to include few ideas. I will try to keep them at a very high level and focus on their relevance to quantum algorithms.</p>"},{"location":"qip1/ch2a.html#21-nature-of-quantum-information","title":"2.1. Nature of Quantum Information:","text":"<ul> <li>Quantum information is different from the classical information in a sense that the measurements corrupts the state itself</li> <li>We can prepare any desired pure state, but if we receive such pure state we cannot identify it with certainty (if we dont know how to measure it)</li> <li>Given a unknown quantum state \\(\\left|\\psi\\right&gt;\\) there are three basic operations that we can perform:<ul> <li>Ancilla - take a second, known, quantum system \\(\\left|A\\right&gt;\\) and join it with \\(\\left|\\psi\\right&gt;\\) and treat it as a composite system \\(\\left|\\psi\\right&gt; \\otimes \\left|A\\right&gt;\\)</li> <li>Unitary - we can perform a unitary on \\(\\left|\\psi\\right&gt;\\) and obtain \\(\\left|\\psi^{\\prime}\\right&gt; = U\\left|\\psi\\right&gt;\\) - i.e. all your gates</li> <li>Measurement - we can perform a measurement on \\(\\left|\\psi\\right&gt;\\), or sub-system of it, record the outcome and retain the post-measurement state for further processing</li> </ul> </li> <li>Any quantum operation can be described as a composition of these three operations. Quite often the algorithms used to manipulate information use all of those operations and not just gates</li> </ul>"},{"location":"qip1/ch2a.html#22-no-cloning-theorem","title":"2.2. No-Cloning Theorem:","text":"<ul> <li>Cloning operation of a quantum state \\(\\left|\\psi\\right&gt;\\) is defined as a map \\(\\left|\\psi\\right&gt;_A \\left|0\\right&gt;_B \\rightarrow \\left|\\psi\\right&gt;_A \\left|\\psi\\right&gt;_B\\)</li> <li>We can extend it to a larger system, by adjoining ancilla to it. In this case the cloning operations can be defined as \\(\\left|\\psi\\right&gt;_A \\left|0\\right&gt;_B \\left|M_0\\right&gt;_M \\rightarrow \\left|\\psi\\right&gt;_A \\left|\\psi\\right&gt;_B \\left|M_\\psi\\right&gt;_M\\)</li> <li>No-Cloning Theorem: Let \\(\\mathcal{S}\\) be any set of states of A that contains at least one non-orthogonal state. Then there is no unitary cloning process that achieves cloning for all states in \\(\\mathcal{S}\\).</li> <li>Remark: I am only presenting a proof of 'no-cloning theorem' for the case where the agent is only allowed to perform unitary operations. There exists an extention of this theorem for any 3 basic operations (Ancilla, Unitary, Measurement).</li> </ul>"},{"location":"qip1/ch2a.html#proof","title":"Proof:","text":"<p>Let \\(\\left|\\psi\\right&gt;\\) and \\(\\left|\\phi\\right&gt;\\) be two distinct non-orthogonal states in \\(\\mathcal{S}\\). Lets assume that there exist a unitary \\(U\\) that clone the states in \\(\\mathcal{S}\\).</p> <p>then</p> \\[ U\\left|\\psi\\right&gt;_A \\left|0\\right&gt;_B \\left|M_0\\right&gt;_M = \\left|\\psi\\right&gt;_A \\left|\\psi\\right&gt;_B \\left|M_\\psi\\right&gt;_M \\] \\[ U\\left|\\phi\\right&gt;_A \\left|0\\right&gt;_B \\left|M_0\\right&gt;_M = \\left|\\phi\\right&gt;_A \\left|\\phi\\right&gt;_B \\left|M_\\phi\\right&gt;_M \\] <p>then </p> \\[ \\left&lt;M_0\\right|_M\\left&lt;0\\right|_B\\left&lt;\\psi\\right|_A U^\\dagger U\\left|\\phi\\right&gt;_A \\left|0\\right&gt;_B \\left|M_0\\right&gt;_M = \\left&lt;M_\\psi\\right|_M \\left&lt;\\psi\\right|_B \\left&lt;\\psi\\right|_A \\left|\\phi\\right&gt;_A \\left|\\phi\\right&gt;_B \\left|M_\\phi\\right&gt;_M \\] \\[ \\left&lt;M_0|M_0\\right&gt;_M\\left&lt;0|0\\right&gt;_B\\left&lt;\\psi|\\phi\\right&gt;_A = \\left&lt;M_\\psi|M_\\psi\\right&gt;_M\\left&lt;\\psi|\\phi\\right&gt;_A\\left&lt;\\psi|\\phi\\right&gt;_B \\] \\[ \\left&lt;\\psi|\\phi\\right&gt;_A = \\left&lt;M_\\psi|M_\\phi\\right&gt;_M\\left&lt;\\psi|\\phi\\right&gt;_A\\left&lt;\\psi|\\phi\\right&gt;_B \\] <p>since \\(\\left|\\psi\\right&gt;\\) and \\(\\left|\\phi\\right&gt;\\) are non-orthogonal, we can divide both sides by \\(\\left&lt;\\psi|\\phi\\right&gt;_A\\) and get:</p> \\[ 1 = |\\left&lt;M_\\psi|M_\\phi\\right&gt;_M\\left&lt;\\psi|\\phi\\right&gt;_B| \\] <ul> <li>\\(M_\\psi\\) and \\(M_\\phi\\) are quantum states: \\(|\\left&lt;M_\\psi|M_\\phi\\right&gt;_M| \\leq 1\\),  </li> <li>\\(\\left|\\psi\\right&gt;\\) and \\(\\left|\\phi\\right&gt;\\) are distinct states and so: \\(|\\left&lt;\\psi|\\phi\\right&gt;_B| &lt; 1\\)</li> <li>Therefore we arrive to a contradiction, which completes the proof</li> </ul>"},{"location":"qip1/ch2a.html#herberts-method-of-superluminal-communication","title":"Herbert's method of superluminal communication:","text":"<ul> <li>The no-cloning theorem was crucial for debugging the protocol of superluminal communication proposed by Herbert. See more in Richard's Jozsa notes [4].</li> </ul>"},{"location":"qip1/ch2a.html#23-quantum-teleportation","title":"2.3. Quantum Teleportation:","text":"<p>Consider that Alice and Bob share an entangled Bell state \\(\\left|\\phi^{+}\\right&gt;_{23} = \\frac{1}{\\sqrt{2}}(\\left|00\\right&gt; + \\left|11\\right&gt;)_{23}\\), such that each of them has one qubit of the pair. Additionally Alice has a qubit in a state \\(\\left|\\alpha\\right&gt;_1 = a\\left|0\\right&gt; + b \\left|1\\right&gt;\\). </p> <p>This means that the combined state of the system is:</p> \\[ \\begin{aligned} \\left|\\psi\\right&gt;_{AB} &amp;= \\left|\\alpha\\right&gt;_1 \\left|\\phi^{+}\\right&gt;_{23} = \\left(a\\left|0\\right&gt; + b\\left|1\\right&gt;\\right)_1 \\frac{1}{\\sqrt{2}}(\\left|00\\right&gt; + \\left|11\\right&gt;)_{23} \\\\ &amp; = \\frac{a}{\\sqrt{2}}\\left|000\\right&gt; + \\frac{a}{\\sqrt{2}}\\left|011\\right&gt; + \\frac{b}{\\sqrt{2}}\\left|100\\right&gt; + \\frac{b}{\\sqrt{2}}\\left|111\\right&gt; \\end{aligned} \\] <p>Task: of the quantum teleportation is to transfer the state of \\(\\left|\\alpha\\right&gt;_1\\) to \\(\\left|\\beta\\right&gt;_3\\) by performing local operations and classical communication.</p>"},{"location":"qip1/ch2a.html#algorithm","title":"Algorithm:","text":"<ol> <li>Alice performs a Bell measurement on the two qubits (Performs a projective measurement in the Bell basis)     &lt;!-- 1. Alice applies CX to her qubits 1 and 2<ol> <li>Alice applies H to her qubit 1</li> <li>Alice measures her two qbits to obtain a 2-bit string 00, 01, 10 or 11 --&gt;</li> </ol> </li> <li>Alice sends a 2-bit measurement outcome ij to Bob</li> <li>On receiving ij Bob applies the unitary operation \\(Z^iX^j\\) to his qubit, which is then guaranteed to be in the state \\(\\left|\\alpha\\right&gt;_3\\)</li> </ol> <p>Remark: No information about \\(\\left|\\alpha\\right&gt;_2\\) is left with Alice</p>"},{"location":"qip1/ch2a.html#why-it-works","title":"Why it works:","text":""},{"location":"qip1/ch2a.html#explanation-1","title":"Explanation 1:","text":"<p>(From explanation 1 we would like to learn about how local operations on single qubits can affect the measurement outcome of the measurement of the second qubit.)</p> <p>We can write \\(\\left|\\psi\\right&gt;_{AB}\\) as:</p> \\[ \\begin{aligned} \\left|\\psi\\right&gt;_{AB} &amp;= \\frac{a}{\\sqrt{2}}\\left|000\\right&gt;_{123} + \\frac{a}{\\sqrt{2}}\\left|011\\right&gt;_{123} + \\frac{b}{\\sqrt{2}}\\left|100\\right&gt;_{123} + \\frac{b}{\\sqrt{2}}\\left|111\\right&gt;_{123}\\\\ &amp;= \\frac{a}{2}\\left(\\left|\\psi_{00}\\right&gt;_{12} + \\left|\\psi_{01}\\right&gt;_{12}\\right)\\left|0\\right&gt;_{3} + \\frac{a}{2}\\left(\\left|\\psi_{10}\\right&gt;_{12} + \\left|\\psi_{11}\\right&gt;_{12}\\right)\\left|1\\right&gt;_{3} + \\frac{b}{2}\\left(\\left|\\psi_{10}\\right&gt;_{12} - \\left|\\psi_{11}\\right&gt;_{12}\\right)\\left|0\\right&gt;_{3} + \\frac{b}{2}\\left(\\left|\\psi_{00}\\right&gt;_{12} - \\left|\\psi_{01}\\right&gt;_{12}\\right)\\left|1\\right&gt;_{3} \\\\ &amp;= \\left|\\psi_{00}\\right&gt;_{12}\\left(\\frac{a}{2}\\left|0\\right&gt;_{3} + \\frac{b}{2}\\left|1\\right&gt;_{3}\\right) + \\left|\\psi_{01}\\right&gt;_{12}\\left(\\frac{a}{2}\\left|0\\right&gt;_{3} - \\frac{b}{2}\\left|1\\right&gt;_{3}\\right) + \\left|\\psi_{10}\\right&gt;_{12}\\left(\\frac{a}{2}\\left|1\\right&gt;_{3} + \\frac{b}{2}\\left|0\\right&gt;_{3}\\right) + \\left|\\psi_{11}\\right&gt;_{12}\\left(\\frac{a}{2}\\left|1\\right&gt;_{3} - \\frac{b}{2}\\left|0\\right&gt;_{3}\\right)\\\\ \\end{aligned} \\] <p>Therefore when we measure in which bell state the first two qubits are then we get the following post-measurement states:</p> \\[ \\begin{array}{cc} \\text { mmt outcome } &amp; \\text { post-mmt state } \\\\ 00 &amp; \\left|00\\right&gt;_{12}\\left|\\alpha\\right&gt;_3 \\\\ 01 &amp; \\left|01\\right&gt;_{12}X\\left|\\alpha\\right&gt;_3 \\\\ 10 &amp; \\left|10\\right&gt;_{12}Z\\left|\\alpha\\right&gt;_3 \\\\ 11 &amp; \\left|11\\right&gt;_{12}XZ\\left|\\alpha\\right&gt;_3 \\end{array} \\] <p>Therefore knowing the outcome of the measurement Alice can send a 2-bit string to Bob, who then applies the corresponding operation to his qubit and recovers the state \\(\\left|\\alpha\\right&gt;_3\\)</p>"},{"location":"qip1/ch2a.html#explanation-2","title":"Explanation 2:","text":"<p>(From this explanation we would like to learn how to perform an operation that depends on the measurement outcome.)</p> <p>What I would like to do here is to provide slightly different explanation. I don't like Explanation 1 because it feels very brute forcy, and it doesn't provide any additional intuition about why things are, like they are. The following explanation is perhaps slightly more tricky to grasp, but I think it provides more insight.</p> <p>E.2.1.</p> <p>I would like to start with a simple observation. When we project the first two qubits into the state \\(\\left|\\psi_{00}\\right&gt;_{12}\\) then we get:</p> \\[ \\left&lt;\\psi_{00}\\right|_{12}\\left|\\alpha\\right&gt;_1\\left|\\psi_{00}\\right&gt;_{23} = \\left|\\alpha\\right&gt;_3 \\] <p>One might then ask is it true for more general case? Is this statement true for any state \\(\\left|\\psi_{ij}\\right&gt;_{23}\\):</p> \\[ \\left&lt;\\psi_{ij}\\right|_{12}\\left|\\alpha\\right&gt;_1\\left|\\psi_{ij}\\right&gt;_{23} \\stackrel{?}{=} \\left|\\alpha\\right&gt;_3 \\] <p>This must be true as we can write </p> \\[ \\left&lt;\\psi_{ij}\\right|_{12}\\left|\\alpha\\right&gt;_1\\left|\\psi_{ij}\\right&gt;_{23} = \\left(\\left&lt;\\psi_{00}\\right|_{12} X_2^i Z_2^j\\right)\\left|\\alpha\\right&gt;_1\\left(Z_2^i X_2^j\\left|\\psi_{00}\\right&gt;_{23}\\right) = \\left&lt;\\psi_{00}\\right|_{12}\\left|\\alpha\\right&gt;_1\\left|\\psi_{00}\\right&gt;_{23}= \\left|\\alpha\\right&gt;_3 \\] <p>Wow! This means that quantum teleportation is trivial. If we could perform a projection operation on the first two qubits onto the bell state in which we prepared the pair of second and third qubit, we would simply teleport the state from a qubit 1 to a qubit 3. However, the projection operation is non-unitary and we cannot do it in a unitary way. We need to find workaround. </p> <p>Something that performs a projection operation on the first two qubits is the Bell measurement. This will, however, perform a projective measurement to an arbitrary state and not just the \\(\\left|\\psi_{00}\\right&gt;_{12}\\). The measurement projects the first two qubits into {\\(\\left|\\psi_{00}\\right&gt;_{12}\\), \\(\\left|\\psi_{01}\\right&gt;_{12}\\), \\(\\left|\\psi_{10}\\right&gt;_{12}\\), \\(\\left|\\psi_{11}\\right&gt;_{12}\\)}. Can we somehow know into which state it will project and perform a corresponding operation on the third qubit prior to the measurement?</p> <p>We know it after the measurement, but not before. Before the measurement we cannot know the state into which the measurement will project us (no hidden-variables :)). </p> <p>E.2.2.</p> <p>And here comes the step two: perhaps it doesn't really matter whether we do the operation on the third qubit prior to the measurement or after the measurement. And this I am showing below.</p> \\[ \\left( \\left&lt;\\psi_{ij}\\right|_{12} \\otimes \\mathbb{I}_3\\right) \\left( \\mathbb{I}_{12} \\otimes X_3^i Z_3^j\\right) \\left|\\psi\\right&gt;_{AB} = \\left( \\mathbb{I}_{12} \\otimes X_3^i Z_3^j\\right) \\left( \\left&lt;\\psi_{ij}\\right|_{12} \\otimes \\mathbb{I}_3\\right) \\left|\\psi\\right&gt;_{AB}  = \\left|\\alpha\\right&gt;_3 \\] <p>Et voil\u00e0! It doesn't matter. This is great news, because after the measurement we know into which state we projected the Bell basis. And if we then can perform the unitaries on the qubit 3, we can achieve the same result as if we did it before the measurement.</p> <p>E.2.3.</p> <p>This completes the explanation. What I want to show with this explanation, that you can try to think how to build non-unitary operations on your quantum system if you include the measurement and ancilla as part of your allowed operations. This can quite often suprise you.</p> <p>Feedback: The explanation was coined by me through talking to others and thinking. I haven't seen it anywhere else, so I would love to refine it if you have any ideas how to improve the clarity of the delivery wadamczyk@phys.ethz.ch.</p>"},{"location":"qip1/ch3a.html","title":"Chapter 3a: Computational Complexity:","text":"<p>I will start first by introducing the ideas from the classical computations, and then I will try to extend it to quantum computation and then try to observe the difference. </p> <p>Computational task is usually general i.e. 'given an n-bit string A (for any n), is A prime?'. Studying information theory, we are interested to know how efficient our computation is and whether allowing for some new quantum properties we will improve this computational efficiency. How efficient algorithm is can be measured though algorithm complexity.</p>"},{"location":"qip1/ch3a.html#31-algorithm-complexity","title":"3.1. Algorithm Complexity:","text":"<p>How efficient an algorithm is, can be measured in the amount of resources that are needed to solve a problem of size n.</p> <ul> <li>Time complexity deals with the number of computational steps required for solving the problem</li> <li>Space complexity deals with the amount of RAM that is needed to solve the problem</li> </ul> <p>Big O-Notation is very handy in this case - to easily compare two algorithms</p>"},{"location":"qip1/ch3a.html#32-big-o-notation","title":"3.2. Big O notation:","text":"<p>Below I included definitions from P.Kammerlander lecture, for more intuitive picture go directly to the grey box:</p> <ul> <li> <p>\\(f(n)=o(g(n))\\) and say that \\(f\\) grows slower than \\(g\\) if \\(\\forall c&gt;0 \\exists n_0&gt;0\\) such that for all \\(n \\geq n_0: f(n) \\leq c g(n)\\),</p> </li> <li> <p>\\(f(n)=O(g(n))\\) and say that \\(f\\) does not grow significantly faster than \\(g\\) if \\(\\exists c&gt;0\\) and \\(n_0&gt;0\\) such that for all \\(n \\geq n_0: f(n) \\leq c g(n)\\),</p> </li> <li> <p>\\(f(n)=\\Omega(g(n))\\) and say that \\(f\\) does not grow significantly slower than \\(g\\) if \\(\\exists c&gt;0\\) and \\(n_0&gt;0\\) such that for all \\(n \\geq n_0: c g(n) \\leq f(n)\\),</p> </li> <li> <p>\\(f(n)=\\Theta(g(n))\\) and say that \\(f\\) grows as fast as \\(g\\) if both \\(f(n)=O(g(n))\\) and \\(f(n)=\\Omega(g(n))\\).</p> </li> </ul> <p>Formally, define \\(f(n)=O(g(n))\\) provided \\(|f(n)| \\leq c|g(n)|\\) as \\(n \\rightarrow \\infty\\) - \\(|f(n)|\\) is bounded for some constant \ud835\udc50 and all su\ufb00iciently large \ud835\udc5b. - Intuitively, look at the most significant term. - Ignore constant factors as they seldom dominate and are often transitory</p> <p>For example: consider \\(\ud835\udc5b^2\\) instead of \\(3\ud835\udc5b^2 + 34\ud835\udc5b + 433\\): - The cost of a program is usually a complicated formula. Often we should consider only the most significant term. If the cost is \\(\ud835\udc5b^2 + 99\ud835\udc5b + 900\\) for an input of size \\(\ud835\udc5b\\), then the \\(\ud835\udc5b^2\\) term will eventually dominate, even though \\(99\ud835\udc5b\\) is bigger for \\(\ud835\udc5b &lt; 99\\). The constant term 900 may look big, but it is soon dominated by \\(\ud835\udc5b^2\\).</p> <p>i.e. We don't care in this case whether each time-step will take 1minute or 1ms, as for sufficiently large problem it wont matter. If we can make the algorithm more efficient, there will exist a n, for which the slow computer will be solving problem of size n faster.</p> <p>Simple Facts about O Notation:</p> <ul> <li>\\(\\begin{array}{r}O(2 g(n)) \\text { is the same as } O(g(n)) \\\\ O\\left(\\log _{10} n\\right) \\text { is the same as } O(\\ln n) \\\\ O\\left(n^2+50 n+36\\right) \\text { is the same as } O\\left(n^2\\right) \\\\ O\\left(n^2\\right) \\text { is contained in } O\\left(n^3\\right) \\\\ O\\left(2^n\\right) \\text { is contained in } O\\left(3^n\\right) \\\\ O(\\log n) \\text { is contained in } O(\\sqrt{n})\\end{array}\\)</li> </ul> <p>Above is taken from [4]</p>"},{"location":"qip1/ch3a.html#33-complexity-classes","title":"3.3. Complexity Classes:","text":"<p>Decision Problem is a problem that can be formulated as a yes-no question of the input value. </p> <p>Zoo of Complexity Classes</p> <ul> <li>P: (Polynomial) The class of decision problems that can be solved in polynomial time on a classical computer.</li> <li>BPP: (Bounded-Error probabilistic polynomial time) The class of decision problems that can be solved by a probabilistic algorithm in polynomial time on a classical computer with failure probability at most \\(\\frac{1}{3}\\) for all possible inputs.</li> <li>NP: The class of decision problems such that, if the answer is \u2018yes\u2019, there is a proof of this which can be verified in polynomial time on a classical computer.</li> <li>PSPACE: (Space complexity polynomial) The class of decision problems that can be solved in polynomial space on a classical computer.</li> <li>NP-complete: A problem is said to be NP-complete if it is in NP and any other problem in NP can be reduced to it in polynomial time.</li> <li>BQP: The class of decision problems that can be solved in polynomial time on a quantum computer with failure probability at most \\(\\frac{1}{3}\\) for all possible inputs.</li> </ul> <p>Some facts:</p> <ul> <li>\\(\\mathbf{P} \\subset \\mathbf{B P P}\\)</li> <li>\\(\\mathbf{P} \\subset \\mathbf{N P} \\subset \\mathbf{P S P A C E}\\)</li> <li>It is not known whether \\(\\mathbf{B P P} \\subset \\mathbf{N P}\\)</li> <li>Factorisation is not known and not believed to be NP-complete</li> <li>We dont know whether \\(\\mathbf{P} = \\mathbf{B P P}\\), although many believe so</li> </ul>"},{"location":"qip1/ch3a.html#34-quantum-complexity","title":"3.4. Quantum Complexity","text":"<p>For quantum computers we need to somehow define the operation. Quantum computation is simply application of some unitary operator \\(U \\in \\mathcal{U}(2^n)\\) to some initial state of n qubit (usually \\(\\left|0\\right&gt;=\\left|00 \\cdots 0\\right&gt;=\\left|0^n\\right&gt;=\\left|0\\right&gt;^{\\otimes n}\\)), followed by a measurement m of the qubits in the computational basis. Any \\(U \\in \\mathcal{U}(2^n)\\) is composed of an elementary gate from \\(\\mathcal{S}\\).</p> <ul> <li>circuit size is the number of elementary gates</li> <li>circuit width is the number of s-qubits that are involved in those elementary gates</li> <li>circuit depth is the number of actual time steps needed while allowing for parallel execution of elementary gates on di\u2000erent qubits. However, the depth di\u2000ers from the size at most by a constant factor of s and is hence not relevant for the asymptotic runtime.</li> </ul>"},{"location":"qip1/ch3b.html","title":"Chapter 3b: Universal gates, Reversible irreversability, Oracle Functions","text":""},{"location":"qip1/ch3b.html#35-universal-sets-of-gates","title":"3.5. Universal sets of gates","text":"<p>\\(\\mathcal{S}\\) is universal set of gates for quantum computing if for any \\(n \\in \\mathbb{N}\\) an arbitrary unitary operation \\(U \\in \\mathcal{U}(n)\\) can be implemented to arbitrary precision using only elementary gates from \\(\\mathcal{S}\\). Elementary gates are assumed to take \\(O(1)\\) time.</p> <ul> <li>Examples of the universal set of gates:<ul> <li>\\(\\{CNOT\\} \\cup \\mathcal{U}(2)\\)</li> <li>\\(\\{CNOT, H, T\\}\\)</li> <li>\\(\\{\\text{Toffoli}, H\\}\\)</li> </ul> </li> </ul> <p>For any fixed universal set \\(\\mathcal{S}\\), a generic unitary matrix on n qubits requires exponentially many elementary gates n to be implemented - this follows from the fact that an n-qubit unitary is determined by \\(O(4^n)\\) real parameters. Goal of quantum computing is to find efficient quantum circuits which use poly(n) qubits and poly(n) elementary gates to solve a problem on an input size n.</p>"},{"location":"qip1/ch3b.html#36-simulating-classical-circuits-on-a-quantum-machine-leftmathbfb-p-p-subset-mathbfb-q-pright","title":"3.6. Simulating Classical Circuits on a Quantum Machine \\(\\left(\\mathbf{B P P} \\subset \\mathbf{B Q P}\\right)\\)","text":"<p>A classical circuit is a sequence of logical operations that act on a small number of bits (AND, OR, NOT). We claim that quantum computation is at least as powerfull as classical computation \\(\\mathbf{B P P} \\subset \\mathbf{B Q P}\\). However, the difficulty in proving it arise when we try to translate irreversible classical operations, such as AND or OR, to quantum gates.Quantum operations are unitary, hence reversible. This poses a problem:</p> <p>The crucial step in showing that one can simulate any classical circuit with a quantum circuit involves showing that any classical boolean operation (even irreversible) can be represented through reversible operation on larger hilbert space. The key point is that if we operate with unitaries on a larger space, but we only look at the subspace, it will look like the operation is non-unitary, (irreversible).</p> <p>Claim: If \\(f: B_m \\rightarrow B_n\\) is a Boolean function it can be expressed in an equivalent reversible form \\(\\tilde{f}: B_{m+n} \\rightarrow B_{m+n}\\).</p> <p>Remark: The claim by itself is simply logic and has nothing to do with quantum computing.</p> <p>Proof: Consider an binary addition operation \\(\\oplus\\) (adding mod 2). For any \\(f: B_m \\rightarrow B_n\\) define \\(\\tilde{f}:B_{m+n}\\rightarrow B_{m+n}\\), where \\(\\tilde{f}(b, c)=(b, c \\oplus f(b))\\). Such function is reversible, as applying the function twice results in \\((b, c \\oplus f(b) \\oplus f(b)) = (b, c \\oplus 0) = (b, c)\\). If we initialise the second register with \\(c=0...0\\), then \\(\\tilde{f}(b, c) = (b, f(b))\\).</p> <p>Conclusion: Through this we satisfied our requirement to represent an irreversible function \\(f\\) as a reversible function \\(\\tilde{f}\\). By replacing all (now reversible) classical gates with quantum gates, one can obtain quantum circuit that simulates the classical one.</p>"},{"location":"qip1/ch3b.html#37-oracle-for-boolean-function","title":"3.7. Oracle for Boolean function:","text":""},{"location":"qip1/ch3b.html#quantum-oracle","title":"Quantum Oracle","text":"<p>A quantum oracle for any Boolean function \\(f:B_n\\rightarrow B_m\\) will be the quantum gate denoted \\(O_f\\) on \\(n+m\\) qubits defined by its action on basis states as follows. Sometimes we refer to n-qubit register \\(\\left|x\\right&gt;\\) and the m-qubit register \\(\\left|y\\right&gt;\\) as the input and output registers respectively $$ O_f\\left|x\\right&gt;\\left|y\\right&gt;=\\left|x\\right&gt;\\left|y \\oplus f(x)\\right&gt; \\quad \\text { for all } x \\in B_n \\text { and } y \\in B_m $$</p>"},{"location":"qip1/ch3b.html#phase-oracle","title":"Phase Oracle","text":"<p>A phase oracle will be quantum gate denoted \\(U_f\\) on \\(n+m\\) qubits defined by its action on basis states as follows  $$ U_f\\left|x\\right&gt;=(-1)^{f(x)}\\left|x\\right&gt; $$</p> <p>This can be achieved through \\(O_f\\) $$ O_f\\left|x\\right&gt;\\left|-\\right&gt;=O_f \\left|x\\right&gt; \\frac{1}{\\sqrt{2}}(\\left|0\\right&gt;-\\left|1\\right&gt;)=\\frac{1}{\\sqrt{2}}(\\left|x\\right&gt;\\left|f(x)\\right&gt;-\\left|x\\right&gt;\\left|1 \\oplus f(x)\\right&gt;)=(-1)^{f(x)}\\left|x\\right&gt;\\left|-\\right&gt; $$</p>"},{"location":"qip1/ch3b.html#38-query-complexity","title":"3.8. Query Complexity:","text":"<p>Let us for a second come back to the complexity classes. In computation it is quite often tricky to consider all gates that are involved in the circuit. But in the end, quite often, we dont care what is the exact time complexity of the circuit. What we rather care about, is how does the complexity of the classical algorithm compares with the complexity of the quantum algorithm.</p> <p>And for this, we can group the gates into queries - both for classical computation and for quantum computation. For instance, an oracle function \\(O_f\\) is just a collection of gates. We also know that the complexity of the quantum oracle is at least as efficient as the classical oracle.</p> <p>This means that if we find that the quantum algorithm is more efficient in the number of queries than the classical algorithm, then the quantum time complexity is definitely better than the classical one.</p> <p>Query complexity is the number of times we need to apply the oracle to the circuit.</p>"},{"location":"qip1/ch3b.html#39-computation-by-quantum-parallelism","title":"3.9. Computation by quantum parallelism:","text":"<p>Now we can talk about what happens when we apply the oracle to a state in a superposition. This is the heart of what makes quantum computers powerful. Consider we have a state in a superposition of all possible inputs \\(\\left|\\psi\\right&gt; = \\frac{1}{\\sqrt{2^n}}\\sum_x\\left|x\\right&gt;\\left|0\\right&gt;\\). Then if we apply the oracle to this state, we get:</p> \\[ O_f\\left|\\psi\\right&gt; = \\frac{1}{\\sqrt{2^n}}\\sum_x O_f\\left|x\\right&gt;\\left|0\\right&gt; = \\frac{1}{\\sqrt{2^n}}\\sum_x \\left|x\\right&gt;\\left|f(x)\\right&gt; \\] <p>This is what we call the computation by quantum parallelism. Fundamentally this is what differentiates quantum computing from classical computing. In classical computing we cannot have states that are in superposition of different inputs. In quantum computing we can, and this allows us to compute the function in parallel for all possible inputs.</p> <p>Problem however is that we dont have a conclusive result from this, if we don't do anything with the result. Consider we now perform a projective measurement on the first register. Then through measuring \\(\\left|x\\right&gt;\\), we can only learn the value of \\(f(x)\\) for a single \\(x\\). </p> <p>Therefore we need to be somewhat more smart what we do with the superposition. This is what you will learn in the next chapter, where we will show how to use the superposition to solve some problems. This is connected to the idea of using interference to solve problems.</p> <p>This subchapter needs some revision to get the point across</p>"},{"location":"qip1/ch3b.html#notes","title":"Notes:","text":"<ul> <li>Things we havent talk about in detail is the concept of universal sets of quantum gates, and the approximately universal sets of gates.</li> </ul>"},{"location":"qip1/ch4a.html","title":"Chapter 4a: DJ Style Algorithms:","text":""},{"location":"qip1/ch4a.html#41-deutsch-josza-dj-algorithm","title":"4.1. Deutsch-Josza (DJ) algorithm:","text":"<p>Problem: Given a function \\(f : \\{0,1\\}^n \\rightarrow \\{0, 1\\}\\) with a promise that a function is either constant or balanced the goal is to find out whether \\(f\\) is constant or balanced. Balanced means that it outputs 0 half of the time and 1 the other half of the time. Constant means that it always outputs the same thing (either 1 or 0).</p> <p>Remark: We will show that classical algorithm will require exponentially many queries to \\(f\\), namely \\(2^{n-2}\\) on average. Quantum algorithm will be able to determine whether f is constant or balanced in a single query. Notice here, that we are comparing the query complexity of both classical and quantum algorithms, not the time complexity. But as discussed in the previous chapter this fundamentally means that the quantum algorithm time complexity will be more efficient than the classical equivalent.</p>"},{"location":"qip1/ch4a.html#algorithm","title":"Algorithm:","text":"<p>This circuit corresponds to: 1. Applying \\(H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n}\\). 2. Evaluating the probability of \\(y = 0^n\\), which is equivalent to projecting the state onto \\(\\left|0\\right&gt;^{\\otimes n}\\) and taking the absolute value squared.</p> \\[ \\left|\\left&lt;0\\right|^{\\otimes n}H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n}\\right|^2 = \\begin{cases}1, &amp; \\text { if } f \\text { is constant } \\\\ 0, &amp; \\text { if } f \\text { is balanced }\\end{cases} \\]"},{"location":"qip1/ch4a.html#why-it-works","title":"Why it works?:","text":"<p>There is an explanation in the </p> <p>Explanation 1:</p> <p>What I want you to understand from this explanation is that if we have some sort of symmetric situation due to the measurement - the problem massively simplifies.</p> <p>Here the trick is to realise that operator can act either to the right or to the left. Acting on the left massively simplifies the problem:</p> \\[ \\left&lt;0\\right|^{\\otimes n}H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n} = \\left(\\frac{1}{\\sqrt{2^n}} \\sum_{x \\in\\{0,1\\}^n}\\left&lt;x\\right|\\right) U_f \\left(\\frac{1}{\\sqrt{2^n}} \\sum_{x' \\in\\{0,1\\}^n}\\left|x'\\right&gt;\\right) = \\frac{1}{2^n} \\sum_{x \\in\\{0,1\\}^n}\\left&lt;x\\right| U_f \\left|x\\right&gt; = \\begin{cases}\\pm 1, &amp; \\text { if } f \\text { is constant } \\\\ 0, &amp; \\text { if } f \\text { is balanced }\\end{cases} \\] <p>Because we have equal superposition of all x-values, then if \\(U_f\\) is balanced then they will all add up to \\(0\\), and if they are constant, they will add up to \\(\\pm 1\\).</p> <p>Therefore we get:</p> \\[ \\left|\\left&lt;0\\right|^{\\otimes n}H^{\\otimes n} U_f H^{\\otimes n}\\left|0\\right&gt;^{\\otimes n}\\right|^2 = \\begin{cases}1, &amp; \\text { if } f \\text { is constant } \\\\ 0, &amp; \\text { if } f \\text { is balanced }\\end{cases} \\] <p>As promised</p> <p>Explanation 2:</p> <p>Second explanation is more visual approach to the problem. It requires us to think about the problem slightly differently, which initially might seem more complicated, but then it becomes easier and more natural - I think it is very useful in subsequent problems such as Grover's algorithm</p> <p>We can represent each n-qubit computational basis state as a number corresponding to its binary value  - \\(\\left|0\\right&gt;_C = \\left|00...0\\right&gt;=\\left|0\\right&gt;^{\\otimes n}\\),  - \\(\\left|1\\right&gt;_C = \\left|00...01\\right&gt;\\),  - \\(\\left|2\\right&gt;_C = \\left|00...10\\right&gt;\\) - \u22ee - \\(\\left|2^n-1\\right&gt; = \\left|11...1\\right&gt;\\)</p> <p>Each quantum state \\(\\left|x\\right&gt;_C\\) can be represented as a delta function \\(\\delta(x)\\) on the x-axis, where \\(x\\) ranges from 0 to \\(2^n-1\\).</p> <p>Then let's run through the algorithm step by step:</p> <ol> <li>Initially we have the state \\(\\left|0\\right&gt;_C\\)</li> </ol> <p></p> <ol> <li>Then we apply Haddamard on the \\(\\left|0\\right&gt;_C\\) state, which results in the equal superposition of all states in \\(\\left|x\\right&gt;_C\\) basis</li> </ol> <p></p> <ol> <li>Then we apply \\(U_f\\) operator, which effectively flips the phase of half of the \\(\\left|x\\right&gt;_C\\) states if its balanced, otherwise it flips either all or none of them</li> </ol> <p></p> <ol> <li>Finally we project it onto the equal superposition of all \\(\\left|x\\right&gt;_C\\) states</li> </ol> <p></p> <p>The result is that if half of the states are flipped, then when we project it onto the equal superposition of all \\(\\left|x\\right&gt;_C\\) states, we will measure it with probability 0, and if all the states are flipped, then we will measure it with probability 1</p>"},{"location":"qip1/organisation.html","title":"Organisation","text":""},{"location":"qip1/organisation.html#group-chat","title":"Group Chat:","text":""}]}