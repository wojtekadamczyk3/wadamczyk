{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"qip1_intuition/Chapter%200%3A%20Intention/","title":"Chapter 0: Intention","text":"<p>My plan is to share my edited notes that I made whilst preparing for the teaching. I am doing it mainly in order to make sure I understand the topics, and motivate myself to be clear with explanations. I hope to give different intuition, which perhaps will be useful to some. </p> <p>In case of any queries and feedback, don't hesitate to contact me (wadamczyk@phys.ethz.ch)</p> <p>Resources: Which I used to write my notes - There is a lot of re-writing and paraphrasing, which I havent cited next to the sentence, as it would be inefficient. - Principles of Quantum Mechanics (David Skinner) [1] - Quantum Information Processing (J.P.Home) [2] - Quantum Information and Computation (Richard Jozsa) [3] - Foundations of Computer Science (Anil Madhavapeddy, Jonathan Ludlam) [4] - Quantum Information (C.H.W. Barnes) [5]</p>"},{"location":"qip1_intuition/Chapter%200%3A%20Intention/#chapter-0-introduction","title":"Chapter 0: Introduction","text":"<p>Computation is about manipulation of information. Mathematically we can ponder on the different abstract schemes and systems to manipulate information, however, in practice we are very limited to what type of computation can we really do. \"Information is not a disembodied abstract entity; it is always tied to a physical representation\". [3] \"If information is represented in physical states or degrees of freedom of some physical system, then any possible act of computation, or information processing, must correspond to a physical evolution of that physical system.\" [3] This means that the rules of the computation must obey the laws of physics.</p> <p>Current paradigm of computing relies on classical physics, which in result constrains what operations can we perform on the computers. \"But that is not our World. To the best of our current experimental knowledge, our World is a quantum, not classical.\" [1] This gives us hope. If one carefully isolates and always consideres the whole system, we could enlarge the zoo of the operations we could perform. Extra tools could lead to different complexity classes of the algorithms that were previously not solvable by classical computers, and could aid in further understanding of the world. </p> <p>QIP-Implementation intends to show how can we build systems that can manipulate information using laws of quantum physics. QIP-Concepts intends to entertain the idea that we have the possibility of treating the information in a quantum way. We want to give you the grounding of exploring for yourself how does this change the paradigm of computation.</p> <p>In my notes I will largely \"ignore small formal subtleties, not because they're not interesting, but because they're a distraction from all the interesting physics we want to learn!\" [1]. I will actually skip some of the formalism introduced in the lecture if I feel like it hinders my own understanding of Quantum Mechanics. I am open to being criticised for it. </p>"},{"location":"qip1_intuition/Chapter%201a%3A%20Hilbert%20Space%20and%20Dirac%20Notation/","title":"Chapter 1a: Hilbert spaces, Dirac Notation, Operators, and Postulates","text":""},{"location":"qip1_intuition/Chapter%201a%3A%20Hilbert%20Space%20and%20Dirac%20Notation/#11-hilbert-spaces","title":"1.1. Hilbert spaces:","text":"<p>Hilbert Space: - Hilbert space is a vector space \\(\\mathcal{H}\\) over \\(\\mathbb{C}\\) that is equipped with a complete inner product.  - This definition has 3 keywords:      - Vector space - is well known,      - Complete - is just a hedge against infinite Hilbert Spaces (unimportant)     - Inner Product is a map \\((\\quad,\\quad): \\mathcal{H} \\times \\mathcal{H} \\rightarrow \\mathbb{C}\\) that obeys</p> \\[ \\begin{aligned} \\text { conjugate symmetry } &amp; (\\phi, \\psi)=\\overline{(\\psi, \\phi)} \\\\ \\text { linearity } &amp; (\\phi, a \\psi)=a(\\phi, \\psi) \\\\ \\text { additivity } &amp; (\\phi, \\psi+\\chi)=(\\phi, \\psi)+(\\phi, \\chi) \\\\ \\text { positive-definiteness } &amp; (\\psi, \\psi) \\geq 0 \\forall \\psi \\in \\mathcal{H} \\end{aligned} \\] <ul> <li>Metric of \\(\\mathcal{H}\\) is defined by the norm \\(\\|\\psi\\| \\equiv \\sqrt{(\\psi, \\psi)}\\)</li> <li>Quantum states can be represented as a vectors \\(\\psi \\in \\mathcal{H}\\)</li> </ul> <p>Ignore the concept of homomorphism and endomorphism - its just a bit fancier way to say linear map, and it definitely makes it more difficult to follow the lecture notes.</p> <p>Dual Spaces: - Dual space \\(\\mathcal{H^*}\\) of a \\(\\mathcal{H}\\) is the space of linear maps \\(\\mathcal{H} \\rightarrow \\mathbb{C}\\). That is, an element \\(\\phi \\in \\mathcal{H^*}\\) defines a map \\(\\varphi: \\psi \\mapsto \\varphi(\\psi) \\in \\mathbb{C}\\) for every \\(\\psi \\in \\mathcal{H}\\), such that </p> \\[ \\varphi: a \\psi_1+b \\psi_2 \\mapsto a \\varphi\\left(\\psi_1\\right)+b \\varphi\\left(\\psi_2\\right) $$ - One of the dual space $\\mathcal{H^*}$ is for instance the inner product $(\\phi, \\quad) \\in \\mathcal{H}^*$ for $\\phi \\in \\mathcal{H}$, where  $$ (\\phi, \\quad): \\psi \\mapsto(\\phi, \\psi) \\]"},{"location":"qip1_intuition/Chapter%201a%3A%20Hilbert%20Space%20and%20Dirac%20Notation/#12-dirac-notation","title":"1.2. Dirac Notation:","text":"<p>In quantum mechanics quite often we often switch basis. This is because intrinsically any measurement causes a collapse onto the measurement basis. Because of this we want to have a notation that allows us to work with multiple basis at the same time, and not get confused. Dirac notation (empirically) provides this clarity. It is difficult to formally define the notation, and quite often when one does it, they get confused (unless they are deep down in theory). Therefore I would propose to learn it through learning the basic few properties and then trying things out. When thinking whether some operation is legal or not - ask me or your friends. Through discussion you will get deeper understanding of the concept. </p> <p>Dirac denotes element of \\(\\mathcal{H}\\) as \\(\\left|\\psi\\right&gt;\\) 'ket', and an element of the dual space is written as \\(\\mathcal{H^*}\\) as \\(\\left&lt;\\psi\\right|\\) 'bra'. The inner product between two states \\(\\left|\\psi\\right&gt;, \\left|\\phi\\right&gt; \\in \\mathcal{H}\\) is written as \\(\\left&lt;\\psi|\\phi\\right&gt;\\).</p> <p>In notes the bra-ket notation is introduced using homomorphisms (linear maps). I find it unecessary. - The advantage of using bra-ket notation is:     - We can talk about multiple things at the same time - Dirac notation is effectively just a label that points to an abstract object in the Hilbert space. We don't need to specify whether the variable is contineous, or if it is a vector or a function.     - Allows us to label states by their eigenvalues     - Somehow it is more natural and causes less confusion</p>"},{"location":"qip1_intuition/Chapter%201a%3A%20Hilbert%20Space%20and%20Dirac%20Notation/#13-operators","title":"1.3. Operators:","text":"<ul> <li>A linear operator A is a map \\(A : \\mathcal{H} \\rightarrow \\mathcal{H}\\) that is compatible with the vector space structure \\(A(c_1\\left|\\phi_1\\right&gt; + c_2\\left|\\phi_2\\right&gt;) = c_1A\\left|\\phi_1\\right&gt; + c_2A\\left|\\phi_2\\right&gt;\\)</li> <li>All operators in Quantum Mechanics are linear, hence we will call them just 'operators'</li> <li>Operators form algebra<ul> <li>Sum: \\((\\alpha A+\\beta B):\\left|\\phi\\right&gt; \\mapsto \\alpha A\\left|\\phi\\right&gt;+\\beta B\\left|\\phi\\right&gt;\\)</li> <li>Product: \\(A B: \\phi \\mapsto A \\circ B\\left|\\phi\\right&gt;=A(B\\left|\\phi\\right&gt;)\\)</li> <li>Commutator: \\([A, B]=A B-B A\\)</li> </ul> </li> <li>A state \\(\\psi \\in \\mathcal{H}\\) is said to be an eigenstate of an operator A if \\(A\\left|\\psi\\right&gt; = a_\\psi\\left|\\psi\\right&gt;\\) with an associated eigenvalue '\\(a_\\psi\\)'.</li> <li>Adjoint \\(A^\\dagger\\) of an operator \\(A\\) is defined as \\(\\left&lt;\\phi\\right|A^{\\dagger}\\left| \\psi\\right&gt;=\\overline{\\left&lt;\\psi\\right|A\\left| \\phi\\right&gt;} \\quad\\)</li> <li>An operator \\(Q\\) is called Hermitian if \\(Q^\\dagger=Q\\)</li> <li>An operator \\(U\\) is called Unitary if \\(U^\\dagger U= U U^\\dagger = \\mathbb{I}\\)</li> <li>An operator \\(\\Pi\\) is called Projector if \\(\\Pi\\Pi= \\Pi\\)</li> </ul>"},{"location":"qip1_intuition/Chapter%201a%3A%20Hilbert%20Space%20and%20Dirac%20Notation/#14-composite-systems","title":"1.4. Composite systems:","text":"<p>Tensor Product - Tensor product \\(\\mathcal{H}_1 \\otimes \\mathcal{H}_2\\) is a vector space over \\(\\mathbb{C}\\) spanned by all pairs of elements \\(\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\), where \\(\\left|e_a\\right&gt; \\in \\mathcal{H_1}\\), \\(\\left|f_\\alpha\\right&gt; \\in \\mathcal{H_2}\\) - It is not true that a general element of \\(\\mathcal{H}_1 \\otimes \\mathcal{H}_2\\) necessarily takes the form \\(\\left|\\psi_1\\right&gt;\\otimes\\left|\\psi_2\\right&gt;\\) - Rahter, a general element may be written as \\(\\left|\\Psi\\right&gt;=\\sum_{a, \\alpha} r_{a \\alpha}\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\) - Elements of the form \\(\\left|\\psi_1\\right&gt;\\otimes\\left|\\psi_2\\right&gt;\\) are called simple, and the elements of the form \\(\\left|\\Psi\\right&gt;=\\sum_{a, \\alpha} r_{a \\alpha}\\left|e_a\\right&gt; \\otimes\\left|f_\\alpha\\right&gt;\\) are refered as entangled - \\(\\left&lt;\\alpha\\otimes\\beta|\\alpha'\\otimes\\beta'\\right&gt; := \\left&lt;\\alpha|\\alpha'\\right&gt;\\left&lt;\\beta|\\beta'\\right&gt;\\) - \\(\\left( S_\\alpha \\otimes T_\\beta \\right)\\left(\\alpha \\otimes \\beta\\right) = \\left(S_\\alpha\\alpha\\right)\\otimes\\left(T_\\beta\\beta\\right)\\) - apologies for being slightly sloppy - I think it is understandable what I mean though</p>"},{"location":"qip1_intuition/Chapter%201a%3A%20Hilbert%20Space%20and%20Dirac%20Notation/#15-postulates-of-quantum-mechanics","title":"1.5. Postulates of Quantum Mechanics:","text":"<ul> <li>(1) A quantum system A is associated with complex Hilber space \\(\\mathcal{H}\\). A physical state of an isolated system is represented by a normalised vector \\(\\left|\\psi\\right&gt; \\in \\mathcal{H}\\), which is unique up to a phase factor</li> <li>(2) The evolution of an isolated quantum system is reversible. In this formalism this corresponds to unitary evolution of the form \\(\\left|\\psi\\right&gt; \\mapsto U\\left|\\psi\\right&gt;\\) for \\(U \\in \\mathcal{U}(\\mathcal{H})\\), i.e. \\(U^{\\dagger} U=U U^{\\dagger}=\\mathbb{I}\\). The unitary is unique up to a phase factor</li> <li>(3) Composite system - For two quantum system A, and B with associated Hilber spaces \\(\\mathcal{H_A}\\) and \\(\\mathcal{H_B}\\) the Hilbert space \\(\\mathcal{H_{AB}}\\) associated with the composite system AB is isomorphic to the tensor product \\(\\mathcal{H_A}\\otimes\\mathcal{H_B}\\). For unitary operation on the subsystem we use: \\(U_A \\otimes \\mathbb{I}_B\\left|i j\\right&gt;_{A B} \\equiv U_A\\left|i j\\right&gt;_{A B}\\)</li> <li>(4) Measurement - A projective measurement on a quantum system with outcomes labelled \\({x}_x\\) is associated with a set of projectors \\({\\Pi_x}x\\) satisfying \\(\\sum_x \\Pi_x = \\mathbb{I}\\). <ul> <li>Probability of getting outcome x when measuring state $\\left|\\psi\\right&gt; is given by the Born rule: \\(Pr[x \\mid \\psi]=\\left\\langle\\psi\\left|\\Pi_x\\right| \\psi\\right\\rangle\\)</li> <li>Post-measurement state is given the outcome x is \\(\\left|\\psi_x^{\\prime}\\right&gt;=\\frac{1}{\\sqrt{\\operatorname{Pr}[x \\mid \\psi]}} \\Pi_x\\left|\\psi\\right&gt;=\\frac{\\Pi_x\\left|\\psi\\right&gt;}{\\sqrt{\\left\\langle\\psi\\left|\\Pi_x\\right| \\psi\\right\\rangle}}\\)</li> </ul> </li> </ul>"},{"location":"qip1_intuition/Chapter%201b%3A%20Pure%20States%20and%20Quantum%20Circuits/","title":"Chapter 1b: Usefull Toolbox","text":""},{"location":"qip1_intuition/Chapter%201b%3A%20Pure%20States%20and%20Quantum%20Circuits/#16-bell-basis","title":"1.6. Bell Basis","text":"<ul> <li>Let \\(\\mathcal{H}_{A B}=\\mathcal{H}_A \\otimes \\mathcal{H}_B \\cong \\mathbb{C}^4\\) be the bipartite Hilbert space of two qubits and consider the product basis of the computational bases of the qubit subsystems. For \\(\\mathcal{H_{AB}}\\) there exists a basis consisting of maximally entangled states denotes as:</li> </ul> \\[\\begin{array}{ll}\\left|\\psi^{00}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|00\\right&gt;+\\left|11\\right&gt;) &amp; =\\left|\\Phi^{+}\\right&gt; \\\\ \\left|\\psi^{01}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|00\\right&gt;-\\left|11\\right&gt;) &amp; =\\left|\\Phi^{-}\\right&gt; \\\\ \\left|\\psi^{10}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|01\\right&gt;+\\left|10\\right&gt;) &amp; =\\left|\\Psi^{+}\\right&gt; \\\\ \\left|\\psi^{11}\\right&gt;=\\frac{1}{\\sqrt{2}}(\\left|01\\right&gt;-\\left|10\\right&gt;) &amp; =\\left|\\Psi^{-}\\right&gt;\\end{array}\\] <ul> <li>The first number stands for parity, the second number stands for phase. \\(\\left|\\psi^{10}\\right&gt;\\) has parity 1 (odd number of 1's), and relative phase \\((-1)^0=1\\)</li> <li>The maximally entangled states are locally convertible - there exist local operations on the subsystem B that transforms one Bell state into another Bell state. \\(\\(\\left|\\psi^{i j}\\right&gt;=\\left(\\mathbb{I}_A \\otimes X_B^i Z_B^j\\right)\\left|\\psi^{00}\\right&gt;\\)\\)</li> </ul>"},{"location":"qip1_intuition/Chapter%201b%3A%20Pure%20States%20and%20Quantum%20Circuits/#17-quantum-circuits","title":"1.7. Quantum Circuits","text":"<p>Example Quantum circuit</p> <p> </p> <p>corresponds to unitary operator \\(\\left(V \\otimes \\mathbb{I}\\right)\\left(\\mathbb{I}\\otimes U\\right)\\left(H\\otimes\\mathbb{I}\\otimes Z\\right)\\) applied to three qubits followed by a Z-measurement of the first qubit</p> <p>Common Gates - Haddamard Gate:     - \\(H=\\frac{1}{\\sqrt{2}}\\left(\\begin{array}{cc}1 &amp; 1 \\\\ 1 &amp; -1\\end{array}\\right)=\\left|+\\right&gt;\\left&lt; 0\\right|+\\left|-\\right&gt; \\left&lt;1\\right|=\\left| 0\\right&gt;\\left&lt;+\\right|+\\left| 1\\right&gt;\\left&lt;-\\right|\\) - Controlled-U Gate:     - \\(\\mathrm{C} U=\\left|0\\right&gt;\\left&lt;0\\right|\\otimes \\mathrm{id}+\\left| 1\\right&gt;\\left&lt;1\\right| \\otimes U\\) - Controlled-Not Gate:     - \\(\\mathrm{CNOT}=\\left(\\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)=\\left|0 \\right&gt;\\left&lt; 0\\right| \\otimes \\mathbb{I}+\\left|1\\right&gt;\\left&lt;1\\right| \\otimes X\\)</p>"},{"location":"qip1_intuition/Chapter%202a%3A%20Complexities/","title":"Chapter 2: Computational Complexity:","text":""},{"location":"qip1_intuition/Chapter%202a%3A%20Complexities/#21-big-o-notation","title":"2.1. Big O notation:","text":"<ul> <li> <p>\\(f(n)=o(g(n))\\) and say that \\(f\\) grows slower than \\(g\\) if \\(\\forall c&gt;0 \\exists n_0&gt;0\\) such that for all \\(n \\geq n_0: f(n) \\leq c g(n)\\),</p> </li> <li> <p>\\(f(n)=O(g(n))\\) and say that \\(f\\) does not grow significantly faster than \\(g\\) if \\(\\exists c&gt;0\\) and \\(n_0&gt;0\\) such that for all \\(n \\geq n_0: f(n) \\leq c g(n)\\),</p> </li> <li> <p>\\(f(n)=\\Omega(g(n))\\) and say that \\(f\\) does not grow significantly slower than \\(g\\) if \\(\\exists c&gt;0\\) and \\(n_0&gt;0\\) such that for all \\(n \\geq n_0: c g(n) \\leq f(n)\\),</p> </li> <li> <p>\\(f(n)=\\Theta(g(n))\\) and say that \\(f\\) grows as fast as \\(g\\) if both \\(f(n)=O(g(n))\\) and \\(f(n)=\\Omega(g(n))\\).</p> </li> </ul> <p>Formally, define \\(f(n)=O(g(n))\\) provided \\(|f(n)| \\leq c|g(n)|\\) as \\(n \\rightarrow \\infty\\) - \\(|f(n)|\\) is bounded for some constant \ud835\udc50 and all su\ufb00iciently large \ud835\udc5b. - Intuitively, look at the most significant term. - Ignore constant factors as they seldom dominate and are often transitory</p> <p>For example: consider \\(\ud835\udc5b^2\\) instead of \\(3\ud835\udc5b^2 + 34\ud835\udc5b + 433\\): - The cost of a program is usually a complicated formula. Often we should consider only the most significant term. If the cost is \\(\ud835\udc5b^2 + 99\ud835\udc5b + 900\\) for an input of size \\(\ud835\udc5b\\), then the \\(\ud835\udc5b^2\\) term will eventually dominate, even though \\(99\ud835\udc5b\\) is bigger for \\(\ud835\udc5b &lt; 99\\). The constant term 900 may look big, but it is soon dominated by \\(\ud835\udc5b^2\\).</p> <p>Simple Facts about O Notation:</p> <ul> <li>\\(\\begin{array}{r}O(2 g(n)) \\text { is the same as } O(g(n)) \\\\ O\\left(\\log _{10} n\\right) \\text { is the same as } O(\\ln n) \\\\ O\\left(n^2+50 n+36\\right) \\text { is the same as } O\\left(n^2\\right) \\\\ O\\left(n^2\\right) \\text { is contained in } O\\left(n^3\\right) \\\\ O\\left(2^n\\right) \\text { is contained in } O\\left(3^n\\right) \\\\ O(\\log n) \\text { is contained in } O(\\sqrt{n})\\end{array}\\)</li> </ul>"},{"location":"qip1_intuition/Chapter%202a%3A%20Complexities/#22-algorithms-efficiency","title":"2.2. Algorithms Efficiency:","text":"<p>How efficient an algorithm is can be measured in the amount of resources that are needed to solve a problem of size n. - Time complexity deals with the number of computational steps required for solving the problem - Space complexity deals with the amount of RAM that is needed to solve the problem</p> <p>As you can imagine O-Notation is very handy in this case - where we can easily compare two algorithms</p> <p>We don't care in this case whether each time-step will take 1minute or 1ms, as for sufficiently large problem it wont matter. If we can make the algorithm more efficient, there will exist a n, for which the slow computer will be solving problem of size n faster.</p>"},{"location":"qip1_intuition/Chapter%202a%3A%20Complexities/#23-what-is-the-deal-with-quantum-computers","title":"2.3. What is the deal with Quantum Computers?","text":"<p>Well, I like this question a lot, because it motivates the whole course. And to understand whats the answer to this question we need to understand the algorithmic complexities. I feel like a lot of people miss-understand what is the real benefit of quantum computers. For example if you ask a random person on a street why are quantum computers usefull - they will probably mark you as a weirdo and ignore you. If you ask a random student in ETH why are quantum computers useful, they will not be able to tell you exactly except mumbling something about parallel nature of computing. This is not entirely right.</p> <p>What is fundamental about q.computing is that due to the extra laws of physics that we can use, we can manipulate information in a new way (on top of the old way). This means that we can design a new algorithms that use those properties that change the complexities of the algorithms. In this course we will show how few of the algorithms change their complexities due to the quantum computing. </p> <p>Here I will introduce commonly used term efficient algorithm is such that it can solve the problem in the polynomial time - i.e. \\(O(n^m)\\)</p>"},{"location":"qip1_intuition/Chapter%202a%3A%20Complexities/#24-complexity-classes","title":"2.4. Complexity Classes:","text":"<ul> <li>P: The class of decision problems that can be solved in polynomial time on a classical computer.</li> <li>BPP: The class of decision problems that can be solved by a probabilistic algorithm in polynomial time on a classical computer with failure probability at most \\(\\frac{1}{3}\\) for all possible inputs.</li> <li>NP: The class of decision problems such that, if the answer is \u2018yes\u2019, there is a proof of this which can be verified in polynomial time on a classical computer.</li> <li>PSPACE: The class of decision problems that can be solved in polynomial space on a classical computer.</li> <li>NP-complete: A problem is said to be NP-complete if it is in NP and any other problem in NP can be reduced to it in polynomial time.</li> </ul> <p>Some facts: - \\(\\mathbf{P} \\subset \\mathbf{B P P}\\) - \\(\\mathbf{P} \\subset \\mathbf{N P} \\subset \\mathbf{P S P A C E}\\) - It is not known whether \\(\\mathbf{B P P} \\subset \\mathbf{N P}\\) - Factorisation is not known and not believed to be NP-complete</p>"}]}